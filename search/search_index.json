{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BoltOn is an open source package which can be used to build any .NET application (like Console, MVC, WebAPI, Windows Service etc.,) with proper separation of concerns quickly. Installation There are a couple of packages for BoltOn available on NuGet. To install BoltOn in your .NET application, type the following command into the Package Manager Console window: PM> Install-Package BoltOn Configuration After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseMvc(); app.ApplicationServices.TightenBolts(); } } } To use other BoltOn packages and/or add other assemblies, you can add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call. BoltOn() This extension method does the following: It groups the executing assembly, all the assemblies of the other modules and the assemblies passed to BoltOnAssemblies() to a collection, sorts them based on the assembly dependencies, and finally scans for all the classes that implement IBootstrapperRegistrationTask and executes them in the order of the assembly dependencies. The assemblies collection can be accessed from RegistrationTaskContext and PostRegistrationTaskContext of the registration tasks. A built-in registration task called BoltOnRegistrationTask registers all the interfaces with single implementation as trasient. Custom registrations: To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. For all the other registration scopes like scoped or singleton, or to register interfaces with more than one implementations, implement IBootstrapperRegistrationTask and use the context.Container (which is of type IServicesCollection ) to register them. Example: public class CustomRegistrationTask : IBootstrapperRegistrationTask { public void Run(RegistrationTaskContext context) { var container = context.Container; container.AddSingleton<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>(); container.AddScoped<ITestService, TestService>(); } } Note: Use the BoltOnOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules. TightenBolts() This extension method scans all the IBootstrapperPostRegistrationTask in the assemblies collection formed by BoltOn() and executes them. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IBootstrapperPostRegistrationTask . Example: public class CustomPostRegistrationTask : IBootstrapperPostRegistrationTask { public void Run(PostRegistrationTaskContext context) { var serviceProvider = context.ServiceProvider; var schoolDbContext = serviceProvider.GetService<TestDbContext>(); testDbContext.Database.EnsureCreated(); } } Logging BoltOn uses .NET Core's logger internally, with just a custom adapter to help in unit testing. You could use any logging provider as you wish, or you could inherit BoltOnNetStandardLoggerAdapter<TType> and override the logging methods. Utilities Check.Requires There are instances where you have to check for a condition and throw exception if the condition fails, in those instances you could use Check.Requires Example: Check.Requires(_serviceCollection != null, \"ServiceCollection not initialized\"); is equivalent to if(_serviceCollection == null) throw new Exception(\"ServiceCollection not initialized\"); and custom exceptions can be thrown like this: Check.Requires<CustomException>(_serviceCollection != null, \"ServiceCollection not initialized\"); IBoltOnClock/BoltOnClock There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IBoltOnClock","title":"Introduction"},{"location":"#installation","text":"There are a couple of packages for BoltOn available on NuGet. To install BoltOn in your .NET application, type the following command into the Package Manager Console window: PM> Install-Package BoltOn","title":"Installation"},{"location":"#configuration","text":"After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseMvc(); app.ApplicationServices.TightenBolts(); } } } To use other BoltOn packages and/or add other assemblies, you can add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call.","title":"Configuration"},{"location":"#bolton","text":"This extension method does the following: It groups the executing assembly, all the assemblies of the other modules and the assemblies passed to BoltOnAssemblies() to a collection, sorts them based on the assembly dependencies, and finally scans for all the classes that implement IBootstrapperRegistrationTask and executes them in the order of the assembly dependencies. The assemblies collection can be accessed from RegistrationTaskContext and PostRegistrationTaskContext of the registration tasks. A built-in registration task called BoltOnRegistrationTask registers all the interfaces with single implementation as trasient. Custom registrations: To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. For all the other registration scopes like scoped or singleton, or to register interfaces with more than one implementations, implement IBootstrapperRegistrationTask and use the context.Container (which is of type IServicesCollection ) to register them. Example: public class CustomRegistrationTask : IBootstrapperRegistrationTask { public void Run(RegistrationTaskContext context) { var container = context.Container; container.AddSingleton<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>(); container.AddScoped<ITestService, TestService>(); } } Note: Use the BoltOnOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules.","title":"BoltOn()"},{"location":"#tightenbolts","text":"This extension method scans all the IBootstrapperPostRegistrationTask in the assemblies collection formed by BoltOn() and executes them. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IBootstrapperPostRegistrationTask . Example: public class CustomPostRegistrationTask : IBootstrapperPostRegistrationTask { public void Run(PostRegistrationTaskContext context) { var serviceProvider = context.ServiceProvider; var schoolDbContext = serviceProvider.GetService<TestDbContext>(); testDbContext.Database.EnsureCreated(); } }","title":"TightenBolts()"},{"location":"#logging","text":"BoltOn uses .NET Core's logger internally, with just a custom adapter to help in unit testing. You could use any logging provider as you wish, or you could inherit BoltOnNetStandardLoggerAdapter<TType> and override the logging methods.","title":"Logging"},{"location":"#utilities","text":"Check.Requires There are instances where you have to check for a condition and throw exception if the condition fails, in those instances you could use Check.Requires Example: Check.Requires(_serviceCollection != null, \"ServiceCollection not initialized\"); is equivalent to if(_serviceCollection == null) throw new Exception(\"ServiceCollection not initialized\"); and custom exceptions can be thrown like this: Check.Requires<CustomException>(_serviceCollection != null, \"ServiceCollection not initialized\"); IBoltOnClock/BoltOnClock There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IBoltOnClock","title":"Utilities"},{"location":"data/","text":"Entity You could create an entity by inheriting BaseEntity<TIdType> where TIdType is the type of the Id property. Entity Framework Repository The core BoltOn package has only the IRepository interface, which could be used in your domain layer if you're into Domain Driven Design. In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create a DbContext by inheriting BaseDbContext<TDbContext> . You could inherit EF's DbContext directy if you're not interested in any of the benefits that BaseDbContext offers. Inherit BaseEFRepository<TEntity, TDbContext> . Add all the database columns to entity properties mapping inside a mapping class by implementing IEntityTypeConfiguration<TEntity> interface. The mapping classes will be automatically added to your DbContext if you inherit BaseDbContext<TDbContext> and if they are in the same assembly where the DbContext resides. Example: // DbContext public class SchoolDbContext : BaseDbContext<SchoolDbContext> { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.Id); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : BaseEFRepository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(IDbContextFactory dbContextFactory) : base(dbContextFactory) { } } EFQueryTrackingBehaviorInterceptor If the request implements IQuery<> or IStaleQuery<> , the DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false with the help of EFQueryTrackingBehaviorInterceptor and DbContextFactory . Note: You could disable this behavior by removing the interceptor from the pipeline using RemoveInterceptor<TInterceptor> extension method.","title":"Data"},{"location":"data/#entity","text":"You could create an entity by inheriting BaseEntity<TIdType> where TIdType is the type of the Id property.","title":"Entity"},{"location":"data/#entity-framework-repository","text":"The core BoltOn package has only the IRepository interface, which could be used in your domain layer if you're into Domain Driven Design. In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create a DbContext by inheriting BaseDbContext<TDbContext> . You could inherit EF's DbContext directy if you're not interested in any of the benefits that BaseDbContext offers. Inherit BaseEFRepository<TEntity, TDbContext> . Add all the database columns to entity properties mapping inside a mapping class by implementing IEntityTypeConfiguration<TEntity> interface. The mapping classes will be automatically added to your DbContext if you inherit BaseDbContext<TDbContext> and if they are in the same assembly where the DbContext resides. Example: // DbContext public class SchoolDbContext : BaseDbContext<SchoolDbContext> { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.Id); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : BaseEFRepository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(IDbContextFactory dbContextFactory) : base(dbContextFactory) { } }","title":"Entity Framework Repository"},{"location":"data/#efquerytrackingbehaviorinterceptor","text":"If the request implements IQuery<> or IStaleQuery<> , the DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false with the help of EFQueryTrackingBehaviorInterceptor and DbContextFactory . Note: You could disable this behavior by removing the interceptor from the pipeline using RemoveInterceptor<TInterceptor> extension method.","title":"EFQueryTrackingBehaviorInterceptor"},{"location":"mediator/","text":"Mediator is the backbone of BoltOn. It follows the Request/Response and Command Message patterns. The main source of inspiration for the Mediator was Agatha , and various other projects like Brighter and MediatR . Request, Response and RequestHandler In order to use the Mediator, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. ICommand To create a request that doesn't have any response and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. ICommand<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. IQuery<out TResponse> To create a request with response of type TResponse and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. If BoltOn.Data.EF is installed and bolted, DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false. IStaleQuery<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadUncommitted will be started for the requests that implement this interface. The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IRequestHandler<in TRequest> or IRequestAsyncHandler<in TRequest> For handlers that do not return any response. IRequestHandler<in TRequest, TResponse> or IRequestAsyncHandler<in TRequest, TResponse> For handlers that have responses. Note: MediatorRegistrationTask takes care of registering the handers to the DI framework. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IRequestAsyncHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } } Interceptors Every request flows thru a set of built-in interceptors, which can be controlled by implementing appropriate marker interfaces. StopwatchInterceptor This interceptor logs the time that a request enters and exits the pipeline. This interceptor is enabled only if the request implements IEnableStopwatchInterceptor interface. UnitOfWorkInterceptor This interceptor starts a transaction with an isolation level based on the interface like IQuery or ICommand etc., (mentioned above) that the request implements. This interceptor is enabled only if the request implements IEnableUnitOfWorkInterceptor You can create an interceptor by implementing IInterceptor interface. If you want to enable or disable an interceptor based on a marker interface implementation, you can inherit BaseRequestSpecificInterceptor<T> Interceptors can be added and removed using the extension methods AddInterceptor<TInterceptor> and RemoveInterceptor<TInterceptor> (in BoltOn.Mediator namespace) respectively. All the interceptors can be removed using the extension method RemoveAllInterceptors . Unit of Work If you use Mediator and implement any of the interfaces mentioned above (like IQuery, ICommand etc.,), you need not worry about starting or committing unit of work, it will be done automatically using UnitOfWorkInterceptor . If you're not using Mediator and if you want to start an unit of work, call Get method in IUnitOfWorkManager by passing UnitOfWorkOptions based on your needs. It will start a new transaction with System.Transactions.TransactionScopeOption.RequiresNew if there is one already started. The default transaction isolation level is IsolationLevel.Serializable Note: Though it's possible to start an unit of work manually, please try to do avoid it, especially when there is already one, as having more than one unit of work isn't a proper way to build applications. This will be useful only when you want to query a database with an isolation level different from the one started by UnitOfWorkInterceptor . In case if you want to change the default transaction isolation level for all the requests or only certain requests, or if you want to change the TransactionTimeout, you can implement IUnitOfWorkOptionsBuilder or inherit UnitOfWorkOptionsBuilder and override the Build method.","title":"Mediator"},{"location":"mediator/#request-response-and-requesthandler","text":"In order to use the Mediator, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. ICommand To create a request that doesn't have any response and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. ICommand<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. IQuery<out TResponse> To create a request with response of type TResponse and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. If BoltOn.Data.EF is installed and bolted, DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false. IStaleQuery<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadUncommitted will be started for the requests that implement this interface. The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IRequestHandler<in TRequest> or IRequestAsyncHandler<in TRequest> For handlers that do not return any response. IRequestHandler<in TRequest, TResponse> or IRequestAsyncHandler<in TRequest, TResponse> For handlers that have responses. Note: MediatorRegistrationTask takes care of registering the handers to the DI framework. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IRequestAsyncHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } }","title":"Request, Response and RequestHandler"},{"location":"mediator/#interceptors","text":"Every request flows thru a set of built-in interceptors, which can be controlled by implementing appropriate marker interfaces. StopwatchInterceptor This interceptor logs the time that a request enters and exits the pipeline. This interceptor is enabled only if the request implements IEnableStopwatchInterceptor interface. UnitOfWorkInterceptor This interceptor starts a transaction with an isolation level based on the interface like IQuery or ICommand etc., (mentioned above) that the request implements. This interceptor is enabled only if the request implements IEnableUnitOfWorkInterceptor You can create an interceptor by implementing IInterceptor interface. If you want to enable or disable an interceptor based on a marker interface implementation, you can inherit BaseRequestSpecificInterceptor<T> Interceptors can be added and removed using the extension methods AddInterceptor<TInterceptor> and RemoveInterceptor<TInterceptor> (in BoltOn.Mediator namespace) respectively. All the interceptors can be removed using the extension method RemoveAllInterceptors .","title":"Interceptors"},{"location":"mediator/#unit-of-work","text":"If you use Mediator and implement any of the interfaces mentioned above (like IQuery, ICommand etc.,), you need not worry about starting or committing unit of work, it will be done automatically using UnitOfWorkInterceptor . If you're not using Mediator and if you want to start an unit of work, call Get method in IUnitOfWorkManager by passing UnitOfWorkOptions based on your needs. It will start a new transaction with System.Transactions.TransactionScopeOption.RequiresNew if there is one already started. The default transaction isolation level is IsolationLevel.Serializable Note: Though it's possible to start an unit of work manually, please try to do avoid it, especially when there is already one, as having more than one unit of work isn't a proper way to build applications. This will be useful only when you want to query a database with an isolation level different from the one started by UnitOfWorkInterceptor . In case if you want to change the default transaction isolation level for all the requests or only certain requests, or if you want to change the TransactionTimeout, you can implement IUnitOfWorkOptionsBuilder or inherit UnitOfWorkOptionsBuilder and override the Build method.","title":"Unit of Work"}]}