{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BoltOn is an open source framework to build any .NET application (like Console, MVC, WebAPI, Windows Service etc.,) with proper separation of concerns. Installation There are a couple of packages for BoltOn available on NuGet. To install BoltOn in your .NET application, type the following command into the Package Manager Console window: PM> Install-Package BoltOn Configuration After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseMvc(); app.ApplicationServices.TightenBolts(); } } } To use other BoltOn packages and/or add other assemblies, you can add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call. BoltOn() This extension method does the following: It groups the executing assembly, all the assemblies of the other modules and the assemblies passed to BoltOnAssemblies() to a collection, sorts them based on the assembly dependencies, and finally scans for all the classes that implement IRegistrationTask and executes them in the order of the assembly dependencies. The assemblies collection can be accessed from RegistrationTaskContext and PostRegistrationTaskContext of the registration tasks. A built-in registration task called BoltOnRegistrationTask registers all the interfaces with single implementation as trasient. Custom registrations: To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. For all the other registration scopes like scoped or singleton, or to register interfaces with more than one implementations, implement IRegistrationTask and use the context.Container (which is of type IServicesCollection ) to register them. Example: public class CustomRegistrationTask : IRegistrationTask { public void Run(RegistrationTaskContext context) { var container = context.Container; container.AddSingleton<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>(); container.AddScoped<ITestService, TestService>(); } } Note: Use the BoltOnOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules. TightenBolts() This extension method scans all the IPostRegistrationTask in the assemblies collection formed by BoltOn() and executes them. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IPostRegistrationTask . Example: public class CustomPostRegistrationTask : IPostRegistrationTask { public void Run(PostRegistrationTaskContext context) { var serviceProvider = context.ServiceProvider; var schoolDbContext = serviceProvider.GetService<TestDbContext>(); testDbContext.Database.EnsureCreated(); } }","title":"Introduction"},{"location":"#installation","text":"There are a couple of packages for BoltOn available on NuGet. To install BoltOn in your .NET application, type the following command into the Package Manager Console window: PM> Install-Package BoltOn","title":"Installation"},{"location":"#configuration","text":"After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseMvc(); app.ApplicationServices.TightenBolts(); } } } To use other BoltOn packages and/or add other assemblies, you can add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call.","title":"Configuration"},{"location":"#bolton","text":"This extension method does the following: It groups the executing assembly, all the assemblies of the other modules and the assemblies passed to BoltOnAssemblies() to a collection, sorts them based on the assembly dependencies, and finally scans for all the classes that implement IRegistrationTask and executes them in the order of the assembly dependencies. The assemblies collection can be accessed from RegistrationTaskContext and PostRegistrationTaskContext of the registration tasks. A built-in registration task called BoltOnRegistrationTask registers all the interfaces with single implementation as trasient. Custom registrations: To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. For all the other registration scopes like scoped or singleton, or to register interfaces with more than one implementations, implement IRegistrationTask and use the context.Container (which is of type IServicesCollection ) to register them. Example: public class CustomRegistrationTask : IRegistrationTask { public void Run(RegistrationTaskContext context) { var container = context.Container; container.AddSingleton<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>(); container.AddScoped<ITestService, TestService>(); } } Note: Use the BoltOnOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules.","title":"BoltOn()"},{"location":"#tightenbolts","text":"This extension method scans all the IPostRegistrationTask in the assemblies collection formed by BoltOn() and executes them. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IPostRegistrationTask . Example: public class CustomPostRegistrationTask : IPostRegistrationTask { public void Run(PostRegistrationTaskContext context) { var serviceProvider = context.ServiceProvider; var schoolDbContext = serviceProvider.GetService<TestDbContext>(); testDbContext.Database.EnsureCreated(); } }","title":"TightenBolts()"},{"location":"data/","text":"Entity You could create an entity by inheriting BaseEntity<TIdType> where TIdType is the type of the Id property. Entity Framework Repository The core BoltOn package has only the IRepository interface, which could be used in your domain layer if you're into Domain Driven Design. In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create a DbContext by inheriting BaseDbContext<TDbContext> . You could inherit EF's DbContext directy if you're not interested in any of the benefits that BaseDbContext offers. Inherit BaseEFRepository<TEntity, TDbContext> . Add all the database columns to entity properties mapping inside a mapping class by implementing IEntityTypeConfiguration<TEntity> interface. The mapping classes will be automatically added to your DbContext if you inherit BaseDbContext<TDbContext> and if they are in the same assembly where the DbContext resides. Example: // DbContext public class SchoolDbContext : BaseDbContext<SchoolDbContext> { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.Id); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : BaseEFRepository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(IDbContextFactory dbContextFactory) : base(dbContextFactory) { } } DbContextFactory This factory uses IServiceProvider to resolve DbContexts, and if the request implements IQuery<> , it sets the DbContexts' ChangeTracker.QueryTrackingBehavior to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled to false with the help of MediatorContextInterceptor . Note: You could disable this behavior by removing the interceptor from the pipeline using RemoveInterceptor<TInterceptor> extension method.","title":"Data"},{"location":"data/#entity","text":"You could create an entity by inheriting BaseEntity<TIdType> where TIdType is the type of the Id property.","title":"Entity"},{"location":"data/#entity-framework-repository","text":"The core BoltOn package has only the IRepository interface, which could be used in your domain layer if you're into Domain Driven Design. In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create a DbContext by inheriting BaseDbContext<TDbContext> . You could inherit EF's DbContext directy if you're not interested in any of the benefits that BaseDbContext offers. Inherit BaseEFRepository<TEntity, TDbContext> . Add all the database columns to entity properties mapping inside a mapping class by implementing IEntityTypeConfiguration<TEntity> interface. The mapping classes will be automatically added to your DbContext if you inherit BaseDbContext<TDbContext> and if they are in the same assembly where the DbContext resides. Example: // DbContext public class SchoolDbContext : BaseDbContext<SchoolDbContext> { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.Id); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : BaseEFRepository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(IDbContextFactory dbContextFactory) : base(dbContextFactory) { } }","title":"Entity Framework Repository"},{"location":"data/#dbcontextfactory","text":"This factory uses IServiceProvider to resolve DbContexts, and if the request implements IQuery<> , it sets the DbContexts' ChangeTracker.QueryTrackingBehavior to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled to false with the help of MediatorContextInterceptor . Note: You could disable this behavior by removing the interceptor from the pipeline using RemoveInterceptor<TInterceptor> extension method.","title":"DbContextFactory"},{"location":"mediator/","text":"Mediator is the backbone of BoltOn. It follows the Request/Response and Command Message patterns. The main source of inspiration for the Mediator was Agatha , and various other projects like Brighter and MediatR . Request, Response and RequestHandler In order to use the Mediator, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. ICommand To create a request that doesn't have any response and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. ICommand<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. IQuery<out TResponse> To create a request with response of type TResponse and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. If BoltOn.Data.EF package is installed and bolted, DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false in DbContextFactory . In case if you want a custom request type with a different isolation level, you could create an interface and customize UnitOfWorkOptionsBuilder by overriding it or by creating a new one. Check out this custom request type called IQueryUncommitted with isolation level ReadUncommitted here . The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IRequestHandler<in TRequest> or IRequestAsyncHandler<in TRequest> For handlers that do not return any response. IRequestHandler<in TRequest, TResponse> or IRequestAsyncHandler<in TRequest, TResponse> For handlers that have responses. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IRequestAsyncHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } } Interceptors Every request flows thru a set of built-in interceptors (mentioned below), and the execution of them can be controlled by implementing appropriate marker interfaces. StopwatchInterceptor This interceptor logs the time that a request enters and exits the pipeline. This interceptor is enabled only if the request implements IEnableStopwatchInterceptor interface. UnitOfWorkInterceptor This interceptor starts a transaction with an isolation level based on the interface like IQuery or ICommand etc., (mentioned above) that the request implements. This interceptor is enabled only if the request implements IEnableUnitOfWorkInterceptor You can create an interceptor by implementing IInterceptor interface, like this . If you want to enable or disable an interceptor based on a marker interface implementation, you can inherit BaseRequestSpecificInterceptor<T> Note: Interceptors from all the bolted modules and assemblies must be added explicitly in the registration tasks using AddInterceptor<TInterceptor> extension method. Interceptors get executed in the order they're added. Interceptors can be removed using RemoveInterceptor<TInterceptor> extension method. All the interceptors in the pipeline (in other packages) can be removed using RemoveAllInterceptors extension method. However, if this extension method is executed in a registration task and if there is another registration task after your registration task to add interceptors, those interceptors will be added to the pipeline. Unit of Work If you use Mediator and implement any of the interfaces like IQuery or ICommand, which in turn implements IEnableUnitOfWorkInterceptor , you need not worry about starting or committing unit of work, it will be done automatically using UnitOfWorkInterceptor . If you're not using Mediator and if you want to start a unit of work, call Get method in IUnitOfWorkManager by passing UnitOfWorkOptions based on your needs. It will start a new transaction with System.Transactions.TransactionScopeOption.RequiresNew if there is one already started. The default transaction isolation level is IsolationLevel.Serializable Note: Though it's possible to start a unit of work manually, please try to do avoid it, especially when there is already one, as having more than one unit of work isn't a proper way to build applications. This will be useful only when you want to query a database with an isolation level different from the one started by UnitOfWorkInterceptor . In case if you want to change the default transaction isolation level for all the requests or only certain requests, or if you want to change the TransactionTimeout, you can implement IUnitOfWorkOptionsBuilder like this or inherit UnitOfWorkOptionsBuilder and override the Build method.","title":"Mediator"},{"location":"mediator/#request-response-and-requesthandler","text":"In order to use the Mediator, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. ICommand To create a request that doesn't have any response and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. ICommand<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. IQuery<out TResponse> To create a request with response of type TResponse and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. If BoltOn.Data.EF package is installed and bolted, DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false in DbContextFactory . In case if you want a custom request type with a different isolation level, you could create an interface and customize UnitOfWorkOptionsBuilder by overriding it or by creating a new one. Check out this custom request type called IQueryUncommitted with isolation level ReadUncommitted here . The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IRequestHandler<in TRequest> or IRequestAsyncHandler<in TRequest> For handlers that do not return any response. IRequestHandler<in TRequest, TResponse> or IRequestAsyncHandler<in TRequest, TResponse> For handlers that have responses. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IRequestAsyncHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } }","title":"Request, Response and RequestHandler"},{"location":"mediator/#interceptors","text":"Every request flows thru a set of built-in interceptors (mentioned below), and the execution of them can be controlled by implementing appropriate marker interfaces. StopwatchInterceptor This interceptor logs the time that a request enters and exits the pipeline. This interceptor is enabled only if the request implements IEnableStopwatchInterceptor interface. UnitOfWorkInterceptor This interceptor starts a transaction with an isolation level based on the interface like IQuery or ICommand etc., (mentioned above) that the request implements. This interceptor is enabled only if the request implements IEnableUnitOfWorkInterceptor You can create an interceptor by implementing IInterceptor interface, like this . If you want to enable or disable an interceptor based on a marker interface implementation, you can inherit BaseRequestSpecificInterceptor<T> Note: Interceptors from all the bolted modules and assemblies must be added explicitly in the registration tasks using AddInterceptor<TInterceptor> extension method. Interceptors get executed in the order they're added. Interceptors can be removed using RemoveInterceptor<TInterceptor> extension method. All the interceptors in the pipeline (in other packages) can be removed using RemoveAllInterceptors extension method. However, if this extension method is executed in a registration task and if there is another registration task after your registration task to add interceptors, those interceptors will be added to the pipeline.","title":"Interceptors"},{"location":"mediator/#unit-of-work","text":"If you use Mediator and implement any of the interfaces like IQuery or ICommand, which in turn implements IEnableUnitOfWorkInterceptor , you need not worry about starting or committing unit of work, it will be done automatically using UnitOfWorkInterceptor . If you're not using Mediator and if you want to start a unit of work, call Get method in IUnitOfWorkManager by passing UnitOfWorkOptions based on your needs. It will start a new transaction with System.Transactions.TransactionScopeOption.RequiresNew if there is one already started. The default transaction isolation level is IsolationLevel.Serializable Note: Though it's possible to start a unit of work manually, please try to do avoid it, especially when there is already one, as having more than one unit of work isn't a proper way to build applications. This will be useful only when you want to query a database with an isolation level different from the one started by UnitOfWorkInterceptor . In case if you want to change the default transaction isolation level for all the requests or only certain requests, or if you want to change the TransactionTimeout, you can implement IUnitOfWorkOptionsBuilder like this or inherit UnitOfWorkOptionsBuilder and override the Build method.","title":"Unit of Work"},{"location":"optional/","text":"Logging BoltOn uses .NET Core's logger internally, with just a custom adapter to help in unit testing. You could use any logging provider as you wish, or you could inherit BoltOnLogger<TType> and override the logging methods. Utilities Check.Requires There are instances where you have to check for a condition and throw exception if the condition fails, in those instances you could use Check.Requires Example: Check.Requires(_serviceCollection != null, \"ServiceCollection not initialized\"); is equivalent to if(_serviceCollection == null) throw new Exception(\"ServiceCollection not initialized\"); and custom exceptions can be thrown like this: Check.Requires<CustomException>(_serviceCollection != null, \"ServiceCollection not initialized\"); IBoltOnClock/BoltOnClock There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IBoltOnClock IQueryUncommitted In case if you want a custom request type which is completely different from IQuery or ICommand in terms of the transaction isolation level or transaction timeout, you could create one something like this: public interface IQueryUncommitted<out TResponse> : IRequest<TResponse>, IEnableUnitOfWorkInterceptor { } And then create a custom interceptor in case if you want to tweak the ChangeTrackerContext, like the one mentioned below and create a custom UnitOfWorkOptionsBuilder to change the transaction isolation level or timeout, like the one mentioned below . And, finally register them like this: serviceCollection.RemoveInterceptor<ChangeTrackerInterceptor>(); serviceCollection.AddInterceptor<CustomChangeTrackerInterceptor>(); serviceCollection.AddTransient<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>(); Interceptor public class CustomChangeTrackerInterceptor : IInterceptor { private readonly ChangeTrackerContext _changeTrackerContext; public CustomChangeTrackerInterceptor(ChangeTrackerContext changeTrackerContext) { _changeTrackerContext = changeTrackerContext; } public TResponse Run<TRequest, TResponse>(IRequest<TResponse> request, Func<IRequest<TResponse>, TResponse> next) where TRequest : IRequest<TResponse> { _changeTrackerContext.IsQueryRequest = request is IQuery<TResponse> || request is IQueryUncommitted<TResponse>; var response = next(request); return response; } public async Task<TResponse> RunAsync<TRequest, TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken, Func<IRequest<TResponse>, CancellationToken, Task<TResponse>> next) where TRequest : IRequest<TResponse> { _changeTrackerContext.IsQueryRequest = request is IQuery<TResponse> || request is IQueryUncommitted<TResponse>; var response = await next(request, cancellationToken); return response; } public void Dispose() { } } UnitOfWorkOptionsBuilder public class CustomUnitOfWorkOptionsBuilder : IUnitOfWorkOptionsBuilder { private readonly IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> _logger; public CustomUnitOfWorkOptionsBuilder(IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> logger) { _logger = logger; } public UnitOfWorkOptions Build<TResponse>(IRequest<TResponse> request) { IsolationLevel isolationLevel; switch (request) { case ICommand<TResponse> _: case IQuery<TResponse> _: case ICommand _: _logger.Debug(\"Getting isolation level for Command or Query\"); isolationLevel = IsolationLevel.ReadCommitted; break; case IQueryUncommitted<TResponse> _: _logger.Debug(\"Getting isolation level for QueryUncommitted\"); isolationLevel = IsolationLevel.ReadUncommitted; break; default: throw new Exception(\"Request should implement ICommand<> or IQuery<> to enable Unit of Work.\"); } return new UnitOfWorkOptions { IsolationLevel = isolationLevel }; } }","title":"Optional"},{"location":"optional/#logging","text":"BoltOn uses .NET Core's logger internally, with just a custom adapter to help in unit testing. You could use any logging provider as you wish, or you could inherit BoltOnLogger<TType> and override the logging methods.","title":"Logging"},{"location":"optional/#utilities","text":"Check.Requires There are instances where you have to check for a condition and throw exception if the condition fails, in those instances you could use Check.Requires Example: Check.Requires(_serviceCollection != null, \"ServiceCollection not initialized\"); is equivalent to if(_serviceCollection == null) throw new Exception(\"ServiceCollection not initialized\"); and custom exceptions can be thrown like this: Check.Requires<CustomException>(_serviceCollection != null, \"ServiceCollection not initialized\"); IBoltOnClock/BoltOnClock There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IBoltOnClock","title":"Utilities"},{"location":"optional/#iqueryuncommitted","text":"In case if you want a custom request type which is completely different from IQuery or ICommand in terms of the transaction isolation level or transaction timeout, you could create one something like this: public interface IQueryUncommitted<out TResponse> : IRequest<TResponse>, IEnableUnitOfWorkInterceptor { } And then create a custom interceptor in case if you want to tweak the ChangeTrackerContext, like the one mentioned below and create a custom UnitOfWorkOptionsBuilder to change the transaction isolation level or timeout, like the one mentioned below . And, finally register them like this: serviceCollection.RemoveInterceptor<ChangeTrackerInterceptor>(); serviceCollection.AddInterceptor<CustomChangeTrackerInterceptor>(); serviceCollection.AddTransient<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>();","title":"IQueryUncommitted"},{"location":"optional/#interceptor","text":"public class CustomChangeTrackerInterceptor : IInterceptor { private readonly ChangeTrackerContext _changeTrackerContext; public CustomChangeTrackerInterceptor(ChangeTrackerContext changeTrackerContext) { _changeTrackerContext = changeTrackerContext; } public TResponse Run<TRequest, TResponse>(IRequest<TResponse> request, Func<IRequest<TResponse>, TResponse> next) where TRequest : IRequest<TResponse> { _changeTrackerContext.IsQueryRequest = request is IQuery<TResponse> || request is IQueryUncommitted<TResponse>; var response = next(request); return response; } public async Task<TResponse> RunAsync<TRequest, TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken, Func<IRequest<TResponse>, CancellationToken, Task<TResponse>> next) where TRequest : IRequest<TResponse> { _changeTrackerContext.IsQueryRequest = request is IQuery<TResponse> || request is IQueryUncommitted<TResponse>; var response = await next(request, cancellationToken); return response; } public void Dispose() { } }","title":"Interceptor"},{"location":"optional/#unitofworkoptionsbuilder","text":"public class CustomUnitOfWorkOptionsBuilder : IUnitOfWorkOptionsBuilder { private readonly IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> _logger; public CustomUnitOfWorkOptionsBuilder(IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> logger) { _logger = logger; } public UnitOfWorkOptions Build<TResponse>(IRequest<TResponse> request) { IsolationLevel isolationLevel; switch (request) { case ICommand<TResponse> _: case IQuery<TResponse> _: case ICommand _: _logger.Debug(\"Getting isolation level for Command or Query\"); isolationLevel = IsolationLevel.ReadCommitted; break; case IQueryUncommitted<TResponse> _: _logger.Debug(\"Getting isolation level for QueryUncommitted\"); isolationLevel = IsolationLevel.ReadUncommitted; break; default: throw new Exception(\"Request should implement ICommand<> or IQuery<> to enable Unit of Work.\"); } return new UnitOfWorkOptions { IsolationLevel = isolationLevel }; } }","title":"UnitOfWorkOptionsBuilder"}]}