{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BoltOn is an open source application framework which can be used to build any type of .NET applications like Console, MVC, WebAPI, Windows Service etc. The components are written in such a way that they're modular , thus they can be bolted on with other components and interchanged easily, and hence the name Bolt-On. Installation To install BoltOn in your .NET application, type the following command in the Package Manager Console window: PM> Install-Package BoltOn From CLI: dotnet add package BoltOn Here is the list of NuGet Packages . Configuration After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc(); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostApplicationLifetime lifeTime) { app.UseMvc(); app.ApplicationServices.TightenBolts(); lifetime.ApplicationStopping.Register( () => app.ApplicationServices.LoosenBolts()); } } } To use other BoltOn packages and/or add other assemblies, add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call. BoltOn() This method does the following: Registers all the interfaces in the calling assembly and assemblies passed to BoltOnAssemblies() method with single implementation as trasient. Registers all the Mediator handlers. Note: The order of the methods called is important though. If BoltOnEFModule() is called after BoltOnAssemblies(), the assemblies passed to the latter method will override the registrations. To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. Use the BoltOnOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules. TightenBolts() This extension method scans all the IPostRegistrationTask in the assembly collection formed by BoltOn() and executes them. The post registration tasks support ctor injection. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IPostRegistrationTask . Example: public class CustomPostRegistrationTask : IPostRegistrationTask { public void Run() { var serviceProvider = context.ServiceProvider; var schoolDbContext = serviceProvider.GetService<TestDbContext>(); testDbContext.Database.EnsureCreated(); } } LoosenBolts() This extension method scans the classes that implement ICleanupTask in all the bolted assemblies and execute them. This is mainly used to dispose and perform other clean-up tasks. Example: public class CleanupTask : ICleanupTask { private readonly IServiceProvider _serviceProvider; public CleanupTask(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; } public void Run() { var busControl = _serviceProvider.GetService<IBusControl>(); busControl?.Stop(); } }","title":"Introduction"},{"location":"#installation","text":"To install BoltOn in your .NET application, type the following command in the Package Manager Console window: PM> Install-Package BoltOn From CLI: dotnet add package BoltOn Here is the list of NuGet Packages .","title":"Installation"},{"location":"#configuration","text":"After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc(); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostApplicationLifetime lifeTime) { app.UseMvc(); app.ApplicationServices.TightenBolts(); lifetime.ApplicationStopping.Register( () => app.ApplicationServices.LoosenBolts()); } } } To use other BoltOn packages and/or add other assemblies, add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call.","title":"Configuration"},{"location":"#bolton","text":"This method does the following: Registers all the interfaces in the calling assembly and assemblies passed to BoltOnAssemblies() method with single implementation as trasient. Registers all the Mediator handlers. Note: The order of the methods called is important though. If BoltOnEFModule() is called after BoltOnAssemblies(), the assemblies passed to the latter method will override the registrations. To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. Use the BoltOnOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules.","title":"BoltOn()"},{"location":"#tightenbolts","text":"This extension method scans all the IPostRegistrationTask in the assembly collection formed by BoltOn() and executes them. The post registration tasks support ctor injection. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IPostRegistrationTask . Example: public class CustomPostRegistrationTask : IPostRegistrationTask { public void Run() { var serviceProvider = context.ServiceProvider; var schoolDbContext = serviceProvider.GetService<TestDbContext>(); testDbContext.Database.EnsureCreated(); } }","title":"TightenBolts()"},{"location":"#loosenbolts","text":"This extension method scans the classes that implement ICleanupTask in all the bolted assemblies and execute them. This is mainly used to dispose and perform other clean-up tasks. Example: public class CleanupTask : ICleanupTask { private readonly IServiceProvider _serviceProvider; public CleanupTask(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; } public void Run() { var busControl = _serviceProvider.GetService<IBusControl>(); busControl?.Stop(); } }","title":"LoosenBolts()"},{"location":"build/","text":"BoltOn uses GitHub Actions for CI and CD. CI involves just building and testing the projects, whereas CD involves building, testing, versioning, packing and publishing to NuGet, and tagging. Though pretty much most of them could be achieved using the GitHub tasks, we are using PowerShell to mainly support performing all the tasks locally. Both the PS scripts ( build.ps1 and publish.ps1 ) use some of the functions in bolton.psm1 . Versioning is done based on Conventional Commits . Here it is: feat: Increments minor version fix: Increments patch version feat! and fix!: Increments major version publish.ps1 script finds all the changed projects in a merge, and increments the version(s) of them based on the commit message. To force changing the versions of projects without making any changes to the project files, scope could be specified in the commit message: Example: feat(BoltOn, BoltOn.Data.EF): test comments Which will increment minor versions of both BoltOn and BoltOn.Data.EF projects, and publish them.","title":"CI & CD"},{"location":"bus/","text":"BoltOn uses MassTransit bus for all the queueing. In order to use the bus, you need do the following: Install BoltOn.Bus.MassTransit NuGet package. Call BoltOnMassTransitModule() in your startup's BoltOn() method. For all the applications that will be just publishing to the queue, configure RabbitMq host and all other settings using MassTransit's extension method for AddMassTransit . Check out this page for the supported configuration. Also refer MassTransit's documentation for all the other supported transports (other than RabbitMq), BoltOnMassTransitModule is transport agnostic. For all the applications that will be consuming messages from the queue, follow all the above steps and then configure BoltOn's BoltOnMassTransitConsumer<TMessage> provided by the above mentioned NuGet package. Finally, inject IBus anywhere in your application and call PublishAsync method to publish your message. Example: Publisher Configuration services.BoltOn(options => { options.BoltOnRabbitMqBusModule(); }); services.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); })); }); Consumer Configuration serviceCollection.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint(host, \"CreateStudent_Queue\", endpoint => { endpoint.Consumer(() => provider.GetService<BoltOnMassTransitConsumer<CreateStudent>>()); }); })); }); You could add an extension method for your transport something like the one mentioned below to configure consumers: public static void BoltOnConsumer<TRequest>(this IRabbitMqBusFactoryConfigurator configurator, IServiceProvider serviceProvider, IRabbitMqHost host, string queueName = null) where TRequest : class, IRequest { configurator.ReceiveEndpoint(host, queueName ?? $\"{typeof(TRequest).Name}_Queue\", endpoint => { endpoint.Consumer(() => serviceProvider.GetService<BoltOnMassTransitConsumer<TRequest>>()); }); } and then call BoltOnConsumer<CreateStudent>(provider, host) Note: As MassTransit had abstracted out the transport like RabbitMq, Azure Service Bus etc., and all the other things very well BoltOn just adds a minor add-on BoltOnMassTransitConsumer<TMessage> to it, which injects IMediator for processing the message of type TMessage . As the consumer injects IMediator and uses it for processing the messages, all the messages should implement any of the interfaces mentioned here . Please refer to Mediator documentation to know how to add handlers and its internals. Starting and stopping bus gets taken care by PostRegistrationTask and CleanupTask respectively.","title":"Bus"},{"location":"cli/","text":"In order to create project templates and other BoltOn components from CLI, execute: dotnet new -i BoltOn.Templates WebAPI To create a .NET Core WebAPI project with BoltOn package bolted: dotnet new bowebapi -n <project_name> -n: Specify the project name. If not specified, the folder name will be used as the project name Handler To create a Mediator handler without response: dotnet new bohandler -n <request_name> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name eg., dotnet new bohandler -n GetStudent The request and the handler will be added in GetStudentHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentRequest : IRequest { } public class GetStudentHandler : IHandler<GetStudentRequest> { public async Task HandleAsync(GetStudentRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } } Handler (with response) To create a Mediator handler with response: dotnet new bohanlder -n <request_name> -r <response_type> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name -r OR --response: Specifiy the type of the response like int, Guid etc. If it's a class type, specify the class name, but you have to create the class eg., dotnet new bohandler -n GetStudentCount -r int The request and the handler will be added in GetStudentsCountHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentsCountRequest : IRequest<int> { } public class GetStudentsCountHandler : IHandler<GetStudentsCountRequest, int> { public async Task<int> HandleAsync(GetStudentsCountRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"CLI"},{"location":"cli/#webapi","text":"To create a .NET Core WebAPI project with BoltOn package bolted: dotnet new bowebapi -n <project_name> -n: Specify the project name. If not specified, the folder name will be used as the project name","title":"WebAPI"},{"location":"cli/#handler","text":"To create a Mediator handler without response: dotnet new bohandler -n <request_name> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name eg., dotnet new bohandler -n GetStudent The request and the handler will be added in GetStudentHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentRequest : IRequest { } public class GetStudentHandler : IHandler<GetStudentRequest> { public async Task HandleAsync(GetStudentRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"Handler"},{"location":"cli/#handler-with-response","text":"To create a Mediator handler with response: dotnet new bohanlder -n <request_name> -r <response_type> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name -r OR --response: Specifiy the type of the response like int, Guid etc. If it's a class type, specify the class name, but you have to create the class eg., dotnet new bohandler -n GetStudentCount -r int The request and the handler will be added in GetStudentsCountHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentsCountRequest : IRequest<int> { } public class GetStudentsCountHandler : IHandler<GetStudentsCountRequest, int> { public async Task<int> HandleAsync(GetStudentsCountRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"Handler (with response)"},{"location":"cqrs/","text":"Command Query Responsibility Segregation (CQRS) pattern derives from the principle Command Query Separation , which states that: [E]very method should either be a command that performs an action, or a query that returns data to the caller, but not both. In other words, Asking a question should not change the answer. \u2013 Wikipedia Command Query Responsibility Separation, or CQRS, takes this principle one step further. CQRS is simply the creation of two objects where there was previously only one. The separation occurs based upon whether the methods are a command or a query (the same definition that is used by Meyer in Command and Query Separation: a command is any method that mutates state and a query is any method that returns a value). \u2013 Greg Young To know more about the CQRS pattern and when to use it, please go over this post . Implementation Most of the CQRS implementations found on the internet mention only about separating the command and the query data stores, but do not mention how to keep the two stores in sync, which is the most challenging part, but BoltOn's CQRS implementation covers it. Data store synchronization could be handled by the following ways: Using a feature like database mirroring (if SQL server), if both the read and writes stores use the same database technology and schemas By persisting data in the write store and publishing an event to an enterprise bus; updating the read store could be handled by a subscriber to the event. But, this will be consistent only if persisting to the write store and publishing are part of a single transaction. As most of the buses do not support transactions, if write store persistence is successful and publishing to bus fails, the read store would be out of sync. Or, the other way, by publishing event to an enterprise bus and then persisting data in the write store. But, this also relies on transaction, else write store could be out of sync. BoltOn overcomes it using outbox pattern . Event sourcing - there are many libraries supporting event sourcing with CQRS. BoltOn synchronizes data using pub/sub, but without using transactions, it's a slight variation of method 2 mentioned above. The implementation was majorly inspired by these series of posts . In BoltOn, business entity is persisted along with the events raised in the same data store as part of a collection within the entity , and then the persisted events get published to the bus. As events are persisted along with the entity, even if the publish fails, events could be republished later on, provided the business is fine with eventual consistency . In order to implement CQRS using BoltOn, you need to do the following: Install BoltOn.Data.EF or BoltOn.Data.CosmosDb NuGet package depending on your read/write data store. Install BoltOn.Bus.MassTransit NuGet package. Refer to Data and Bus documentation to enable the corresponding modules. Enable CQRS by calling BoltOnCqrsModule() in BoltOn() method. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnAssemblies(GetType().Assembly); b.BoltOnEFModule(); b.BoltOnMassTransitBusModule(); b.BoltOnCqrsModule(); }); Configure EF DbContext (if you're using SQL) and MassTransit Bus. Create your domain entity class and inherit BaseCqrsEntity , which will force your entity's Id property to be of type Guid. Create EF mapping configuration class by inheriting BaseCqrsEntityMapping . This takes care of serializing/deserializing EventsToBeProcessed and ProcessedEvents collections. This is done using EF's Value Conversions . Events get triggered from RaiseEvent<TEvent>(TEvent @event) method in the BaseCqrsEntity and they get processed in ProcessEvent<TEvent>(TEvent @event, Action<TEvent> action) . Create your events and inherit CqrsEvent , which implements ICqrsEvent , and which inturn implements Mediator's IRequest , and thus the events can be handled using Mediator . Create your request and handlers, and then use the Mediator to process your request. Please refer to Mediator documentation to create handlers. Register IRepository<TEntity> to EF Repository or CosmosDb Repository . How does it work? The best way to understand the implementation is by looking into BoltOn.Samples.WebApi project's StudentsController and by going thru GET, POST and PUT student endpoints, corresponding requests and their handlers. In this sample we have used only two tables - Student and StudentFlattened in BoltOnSamplesWrite and BoltOnSamplesRead databases respectively. The events that get raised from your entities (that inherit BaseCqrsEntity) get added to EventsToBeProcessed collection. Two entities Student and StudentFlattened inherit BaseCqrsEntity . Student entity is saved in Student table with foreign-key constraint to StudentType table. Commands (aka writes) go to this table. StudentFlattened entity is saved in StudentFlattened table, which is denormalized without any foreign-key constraints. Queries (aka reads) go to this table. Private and internal constructors are added to both the entities. The private constructor is to support EF and the internal constructor is to allow instantiation of the entity with appropriate request object as parameter. Student's internal ctor is called from CreateStudentHandler , which gets invoked by Mediator from StudentController's POST call. StudentCreatedEvent event inherits CqrsEvent . Other properties that are required to create StudentFlattened entity are added. StudentCreatedEvent event is triggered in the ctor by calling the base class' RaiseEvent method. The RaiseEvent method takes care of populating other properties like Id, SourceId, SourceTypeName and CreatedDate. Note: Id property will be initialized only if we don't initialize it, whereas all the other properties listed above will be overridden by the framework. The triggered event gets marked for processing by setting the CreatedDate property to null, and it gets added to EventsToBeProcessed property only if it's not already present. Here is the Student entity: public class Student : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public int StudentTypeId { get; private set; } private Student() { } internal Student(CreateStudentRequest request, string studentType) { Id = Guid.NewGuid(); FirstName = request.FirstName; LastName = request.LastName; StudentTypeId = request.StudentTypeId; RaiseEvent(new StudentCreatedEvent { StudentId = Id, FirstName = FirstName, LastName = LastName, StudentType = studentType, StudentTypeId = StudentTypeId }); } } IRepository<Student> injected in the CreateStudentHandler is registered to use Repository<Student> . Please look into the Startup class in the BoltOn.Samples.WebApi project for all the other registrations. When AddAsync of the repository is called in the handler, the repository adds the entity and on while saving changes, the events marked for processing are added to a request scoped object called EventBag . If CQRS is enabled in the Startup's BoltOn method, CqrsInterceptor is added to the Mediator pipeline. The intercepor calls EventDispatcher to dispatch events that need to be processed, which inturn publishes events using IBus . You could write your own implementation of IEventDispatcher or IBus if the built-in classes do not satisfy your needs. Even if the dispatcher or the bus fails, the events to be processed will be persisted along with the entity, as the CqrsIntercepor is outside the UnitOfWorkIntercepor , which takes care of committing the transaction. If there are more than one event to be processed and if one fails, all the subsequent events dispatching get aborted, so that the order of the events could be maintained. The MassTransit consumer registered to handle StudentCreatedEvent in the BoltOn.Samples.Console project's Startup class handles the event using StudentCreatedEventHandler . Here is the registration: container.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint(\"StudentCreatedEvent_queue\", ep => { ep.Consumer(() => provider.GetService<BoltOnMassTransitConsumer<StudentCreatedEvent>>()); }); })); }); StudentFlattened's internal ctor is called from StudentCreatedHandler , which gets invoked by Mediator from BoltOnMassTransitConsumer<StudentCreatedEvent> StudentCreatedEvent event is processed in the ctor by calling the base class' ProcessEvent method. The action delegate passed as a parameter to the method is invoked only if the event is not already processed. After invoking the action delegate, the DestinationId and the DestinationTypeName properties are populated and the event is added to the ProcessedEvents collection. The ProcessedEvents get persisted along with the entity and thus the collection prevents events getting re-processed. Here is the StudentFlattened entity: public class StudentFlattened : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public string StudentType { get; private set; } private StudentFlattened() { } internal StudentFlattened(StudentCreatedEvent @event) { ProcessEvent(@event, e => { Id = e.StudentId; FirstName = e.FirstName; LastName = e.LastName; StudentType = e.StudentType; StudentTypeId = e.StudentTypeId; }); } } IRepository<StudentFlattened> injected in the StudentCreatedEventHandler is registered to use Repository<StudentFlattened> . When AddAsync of the repository is called in the handler, the repository adds the entity and on while saving changes using the SaveChanges method, the processed events' ProcessedDate is populated and persisted. If IRepository<StudentFlattened> is registered to inject CosmosDb Repository and appropriate CosmosDb configurations are added, data can be synced to CosmosDb. Note: To purge the events to be processed right after dispatching them, set CqrsOptions' PurgeEventsToBeProcessed property to true while bootstraping the app. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnAssemblies(GetType().Assembly); b.BoltOnEFModule(); b.BoltOnMassTransitBusModule(); b.BoltOnCqrsModule(o => o.PurgeEventsToBeProcessed = true); }); It's handled using EventPurger . You could write your own implementation of IEventPurger if the built-in purger do not satisfy your needs. In case if the RabbitMq is down, EventsToBeProcessed will get persisted along with the entity, but dispatching will fail, so it's better to write an utility to go over the write store periodically and dispatch all the unprocessed events in the EventsToBeProcessed collection of every entity. Or, implement some sort of outbox pattern . Over a period of time, ProcessedEvents collection could bloat the read entity, so it's better to write an utility to clear them periodically.","title":"CQRS"},{"location":"cqrs/#implementation","text":"Most of the CQRS implementations found on the internet mention only about separating the command and the query data stores, but do not mention how to keep the two stores in sync, which is the most challenging part, but BoltOn's CQRS implementation covers it. Data store synchronization could be handled by the following ways: Using a feature like database mirroring (if SQL server), if both the read and writes stores use the same database technology and schemas By persisting data in the write store and publishing an event to an enterprise bus; updating the read store could be handled by a subscriber to the event. But, this will be consistent only if persisting to the write store and publishing are part of a single transaction. As most of the buses do not support transactions, if write store persistence is successful and publishing to bus fails, the read store would be out of sync. Or, the other way, by publishing event to an enterprise bus and then persisting data in the write store. But, this also relies on transaction, else write store could be out of sync. BoltOn overcomes it using outbox pattern . Event sourcing - there are many libraries supporting event sourcing with CQRS. BoltOn synchronizes data using pub/sub, but without using transactions, it's a slight variation of method 2 mentioned above. The implementation was majorly inspired by these series of posts . In BoltOn, business entity is persisted along with the events raised in the same data store as part of a collection within the entity , and then the persisted events get published to the bus. As events are persisted along with the entity, even if the publish fails, events could be republished later on, provided the business is fine with eventual consistency . In order to implement CQRS using BoltOn, you need to do the following: Install BoltOn.Data.EF or BoltOn.Data.CosmosDb NuGet package depending on your read/write data store. Install BoltOn.Bus.MassTransit NuGet package. Refer to Data and Bus documentation to enable the corresponding modules. Enable CQRS by calling BoltOnCqrsModule() in BoltOn() method. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnAssemblies(GetType().Assembly); b.BoltOnEFModule(); b.BoltOnMassTransitBusModule(); b.BoltOnCqrsModule(); }); Configure EF DbContext (if you're using SQL) and MassTransit Bus. Create your domain entity class and inherit BaseCqrsEntity , which will force your entity's Id property to be of type Guid. Create EF mapping configuration class by inheriting BaseCqrsEntityMapping . This takes care of serializing/deserializing EventsToBeProcessed and ProcessedEvents collections. This is done using EF's Value Conversions . Events get triggered from RaiseEvent<TEvent>(TEvent @event) method in the BaseCqrsEntity and they get processed in ProcessEvent<TEvent>(TEvent @event, Action<TEvent> action) . Create your events and inherit CqrsEvent , which implements ICqrsEvent , and which inturn implements Mediator's IRequest , and thus the events can be handled using Mediator . Create your request and handlers, and then use the Mediator to process your request. Please refer to Mediator documentation to create handlers. Register IRepository<TEntity> to EF Repository or CosmosDb Repository .","title":"Implementation"},{"location":"cqrs/#how-does-it-work","text":"The best way to understand the implementation is by looking into BoltOn.Samples.WebApi project's StudentsController and by going thru GET, POST and PUT student endpoints, corresponding requests and their handlers. In this sample we have used only two tables - Student and StudentFlattened in BoltOnSamplesWrite and BoltOnSamplesRead databases respectively. The events that get raised from your entities (that inherit BaseCqrsEntity) get added to EventsToBeProcessed collection. Two entities Student and StudentFlattened inherit BaseCqrsEntity . Student entity is saved in Student table with foreign-key constraint to StudentType table. Commands (aka writes) go to this table. StudentFlattened entity is saved in StudentFlattened table, which is denormalized without any foreign-key constraints. Queries (aka reads) go to this table. Private and internal constructors are added to both the entities. The private constructor is to support EF and the internal constructor is to allow instantiation of the entity with appropriate request object as parameter. Student's internal ctor is called from CreateStudentHandler , which gets invoked by Mediator from StudentController's POST call. StudentCreatedEvent event inherits CqrsEvent . Other properties that are required to create StudentFlattened entity are added. StudentCreatedEvent event is triggered in the ctor by calling the base class' RaiseEvent method. The RaiseEvent method takes care of populating other properties like Id, SourceId, SourceTypeName and CreatedDate. Note: Id property will be initialized only if we don't initialize it, whereas all the other properties listed above will be overridden by the framework. The triggered event gets marked for processing by setting the CreatedDate property to null, and it gets added to EventsToBeProcessed property only if it's not already present. Here is the Student entity: public class Student : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public int StudentTypeId { get; private set; } private Student() { } internal Student(CreateStudentRequest request, string studentType) { Id = Guid.NewGuid(); FirstName = request.FirstName; LastName = request.LastName; StudentTypeId = request.StudentTypeId; RaiseEvent(new StudentCreatedEvent { StudentId = Id, FirstName = FirstName, LastName = LastName, StudentType = studentType, StudentTypeId = StudentTypeId }); } } IRepository<Student> injected in the CreateStudentHandler is registered to use Repository<Student> . Please look into the Startup class in the BoltOn.Samples.WebApi project for all the other registrations. When AddAsync of the repository is called in the handler, the repository adds the entity and on while saving changes, the events marked for processing are added to a request scoped object called EventBag . If CQRS is enabled in the Startup's BoltOn method, CqrsInterceptor is added to the Mediator pipeline. The intercepor calls EventDispatcher to dispatch events that need to be processed, which inturn publishes events using IBus . You could write your own implementation of IEventDispatcher or IBus if the built-in classes do not satisfy your needs. Even if the dispatcher or the bus fails, the events to be processed will be persisted along with the entity, as the CqrsIntercepor is outside the UnitOfWorkIntercepor , which takes care of committing the transaction. If there are more than one event to be processed and if one fails, all the subsequent events dispatching get aborted, so that the order of the events could be maintained. The MassTransit consumer registered to handle StudentCreatedEvent in the BoltOn.Samples.Console project's Startup class handles the event using StudentCreatedEventHandler . Here is the registration: container.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint(\"StudentCreatedEvent_queue\", ep => { ep.Consumer(() => provider.GetService<BoltOnMassTransitConsumer<StudentCreatedEvent>>()); }); })); }); StudentFlattened's internal ctor is called from StudentCreatedHandler , which gets invoked by Mediator from BoltOnMassTransitConsumer<StudentCreatedEvent> StudentCreatedEvent event is processed in the ctor by calling the base class' ProcessEvent method. The action delegate passed as a parameter to the method is invoked only if the event is not already processed. After invoking the action delegate, the DestinationId and the DestinationTypeName properties are populated and the event is added to the ProcessedEvents collection. The ProcessedEvents get persisted along with the entity and thus the collection prevents events getting re-processed. Here is the StudentFlattened entity: public class StudentFlattened : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public string StudentType { get; private set; } private StudentFlattened() { } internal StudentFlattened(StudentCreatedEvent @event) { ProcessEvent(@event, e => { Id = e.StudentId; FirstName = e.FirstName; LastName = e.LastName; StudentType = e.StudentType; StudentTypeId = e.StudentTypeId; }); } } IRepository<StudentFlattened> injected in the StudentCreatedEventHandler is registered to use Repository<StudentFlattened> . When AddAsync of the repository is called in the handler, the repository adds the entity and on while saving changes using the SaveChanges method, the processed events' ProcessedDate is populated and persisted. If IRepository<StudentFlattened> is registered to inject CosmosDb Repository and appropriate CosmosDb configurations are added, data can be synced to CosmosDb. Note: To purge the events to be processed right after dispatching them, set CqrsOptions' PurgeEventsToBeProcessed property to true while bootstraping the app. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnAssemblies(GetType().Assembly); b.BoltOnEFModule(); b.BoltOnMassTransitBusModule(); b.BoltOnCqrsModule(o => o.PurgeEventsToBeProcessed = true); }); It's handled using EventPurger . You could write your own implementation of IEventPurger if the built-in purger do not satisfy your needs. In case if the RabbitMq is down, EventsToBeProcessed will get persisted along with the entity, but dispatching will fail, so it's better to write an utility to go over the write store periodically and dispatch all the unprocessed events in the EventsToBeProcessed collection of every entity. Or, implement some sort of outbox pattern . Over a period of time, ProcessedEvents collection could bloat the read entity, so it's better to write an utility to clear them periodically.","title":"How does it work?"},{"location":"data/","text":"Entity You could create an entity by inheriting BaseEntity<TIdType> where TIdType is the type of the Id property. Entity Framework Repository The core BoltOn package has only the IRepository interface, which could be used in your domain layer if you're into Domain Driven Design. In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create a DbContext by inheriting BaseDbContext<TDbContext> . You could inherit EF's DbContext directy if you're not interested in any of the benefits that BaseDbContext offers. Inherit Repository<TEntity, TDbContext> to create a repository for your entity. All the repository methods accept an optional parameter options, in FindBy methods, if other navigation properties need to be fetched, a collection of expressions can be passed. Example: var includes = new List<Expression<Func<Student, object>>> { s => s.Addresses }; // act var result = repository.FindBy(f => f.Id == 2, includes).FirstOrDefault(); Add all the database columns to entity properties mapping inside a mapping class by implementing IEntityTypeConfiguration<TEntity> interface. The mapping classes will be automatically added to your DbContext if you inherit BaseDbContext<TDbContext> and if they are in the same assembly where the DbContext resides. In case if you do not want all the mapping configuration classes in the assembly to be added, you can override ApplyConfigurations(ModelBuilder modelBuilder) method of BaseDbContext and add the configuration classes manually. Example: // DbContext public class SchoolDbContext : BaseDbContext<SchoolDbContext> { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.Id); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(IDbContextFactory dbContextFactory, EventBag eventBag, IBoltOnClock boltOnClock) : base(dbContextFactory, eventBag, boltOnClock) { } } Note: Create your own repository like StudentRepository only if you want to override the Repository class' methods or if you want to add methods, else just register IRepository<Student> to Repository<Student, SchoolDbContext> DbContextFactory This factory uses IServiceProvider to resolve DbContexts, and if the request implements IQuery<> , it sets the DbContexts' ChangeTracker.QueryTrackingBehavior to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled to false with the help of MediatorContextInterceptor . Note: You could disable this behavior by removing the interceptor from the pipeline using RemoveInterceptor<TInterceptor> extension method. CosmosDb In order to use CosmosDb, you need do the following: Install BoltOn.Data.CosmosDb NuGet package. Call BoltOnCosmosDbModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create an options class by inheriting BaseCosmosDbOptions class. Use AddCosmosDb extension method to initialize options like URI, AuthorizationKey and Database Name. Inherit Repository<TEntity, TCosmosDbOptions> to create a repository for your entity. All the repository methods accept an optional parameter options. For some of the methods, RequestOptions can be passed and for some FeedOptions can be passed as the options object, take a look at the Repository<TEntity, TCosmosDbOptions> to see the implementation. Example: services.BoltOn(options => { options.BoltOnCosmosDbModule(); }); services.AddCosmosDb<SchoolCosmosDbOptions>(options => { options.Uri = \"<<SPECIFY URI>>\"; options.AuthorizationKey = \"<<SPECIFY AUTHORIZATION KEY>>\"; options.DatabaseName = \"<<DATABASE NAME>>\"; }); public class SchoolCosmosDbOptions : BaseCosmosDbOptions { } // Entity public class Student : BaseEntity<string> { [JsonProperty(\"id\")] public override string Id { get; set; } [JsonProperty(\"studentId\")] public int StudentId { get; set; } public string FirstName { get; set; } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolCosmosDbOptions>, IStudentRepository { public StudentRepository(SchoolCosmosDbOptions options, EventBag eventBag, IBoltOnClock boltOnClock) : base(options, eventBag, boltOnClock) { } } Note: Create your own repository like StudentRepository only if you want to override the Repository class' methods or if you want to add methods, else just register IRepository<Student> to Repository<Student, SchoolCosmosDbOptions> While using any property in CosmosDb query, make sure property name matches exactly as it is in stored in the document collection.","title":"Data"},{"location":"data/#entity","text":"You could create an entity by inheriting BaseEntity<TIdType> where TIdType is the type of the Id property.","title":"Entity"},{"location":"data/#entity-framework-repository","text":"The core BoltOn package has only the IRepository interface, which could be used in your domain layer if you're into Domain Driven Design. In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create a DbContext by inheriting BaseDbContext<TDbContext> . You could inherit EF's DbContext directy if you're not interested in any of the benefits that BaseDbContext offers. Inherit Repository<TEntity, TDbContext> to create a repository for your entity. All the repository methods accept an optional parameter options, in FindBy methods, if other navigation properties need to be fetched, a collection of expressions can be passed. Example: var includes = new List<Expression<Func<Student, object>>> { s => s.Addresses }; // act var result = repository.FindBy(f => f.Id == 2, includes).FirstOrDefault(); Add all the database columns to entity properties mapping inside a mapping class by implementing IEntityTypeConfiguration<TEntity> interface. The mapping classes will be automatically added to your DbContext if you inherit BaseDbContext<TDbContext> and if they are in the same assembly where the DbContext resides. In case if you do not want all the mapping configuration classes in the assembly to be added, you can override ApplyConfigurations(ModelBuilder modelBuilder) method of BaseDbContext and add the configuration classes manually. Example: // DbContext public class SchoolDbContext : BaseDbContext<SchoolDbContext> { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.Id); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(IDbContextFactory dbContextFactory, EventBag eventBag, IBoltOnClock boltOnClock) : base(dbContextFactory, eventBag, boltOnClock) { } } Note: Create your own repository like StudentRepository only if you want to override the Repository class' methods or if you want to add methods, else just register IRepository<Student> to Repository<Student, SchoolDbContext>","title":"Entity Framework Repository"},{"location":"data/#dbcontextfactory","text":"This factory uses IServiceProvider to resolve DbContexts, and if the request implements IQuery<> , it sets the DbContexts' ChangeTracker.QueryTrackingBehavior to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled to false with the help of MediatorContextInterceptor . Note: You could disable this behavior by removing the interceptor from the pipeline using RemoveInterceptor<TInterceptor> extension method.","title":"DbContextFactory"},{"location":"data/#cosmosdb","text":"In order to use CosmosDb, you need do the following: Install BoltOn.Data.CosmosDb NuGet package. Call BoltOnCosmosDbModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create an options class by inheriting BaseCosmosDbOptions class. Use AddCosmosDb extension method to initialize options like URI, AuthorizationKey and Database Name. Inherit Repository<TEntity, TCosmosDbOptions> to create a repository for your entity. All the repository methods accept an optional parameter options. For some of the methods, RequestOptions can be passed and for some FeedOptions can be passed as the options object, take a look at the Repository<TEntity, TCosmosDbOptions> to see the implementation. Example: services.BoltOn(options => { options.BoltOnCosmosDbModule(); }); services.AddCosmosDb<SchoolCosmosDbOptions>(options => { options.Uri = \"<<SPECIFY URI>>\"; options.AuthorizationKey = \"<<SPECIFY AUTHORIZATION KEY>>\"; options.DatabaseName = \"<<DATABASE NAME>>\"; }); public class SchoolCosmosDbOptions : BaseCosmosDbOptions { } // Entity public class Student : BaseEntity<string> { [JsonProperty(\"id\")] public override string Id { get; set; } [JsonProperty(\"studentId\")] public int StudentId { get; set; } public string FirstName { get; set; } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolCosmosDbOptions>, IStudentRepository { public StudentRepository(SchoolCosmosDbOptions options, EventBag eventBag, IBoltOnClock boltOnClock) : base(options, eventBag, boltOnClock) { } } Note: Create your own repository like StudentRepository only if you want to override the Repository class' methods or if you want to add methods, else just register IRepository<Student> to Repository<Student, SchoolCosmosDbOptions> While using any property in CosmosDb query, make sure property name matches exactly as it is in stored in the document collection.","title":"CosmosDb"},{"location":"mediator/","text":"Mediator is the backbone of BoltOn. It follows the Request/Response and Command Message patterns. The main source of inspiration for the Mediator was Agatha , and various other projects like Brighter and MediatR . Request, Response and Handler In order to use the Mediator, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. ICommand To create a request that doesn't have any response and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. ICommand<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. IQuery<out TResponse> To create a request with response of type TResponse and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. If BoltOn.Data.EF package is installed and bolted, DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false in DbContextFactory . In case if you want a custom request type with a different isolation level, you could create an interface and customize UnitOfWorkOptionsBuilder by overriding it or by creating a new one. Check out this custom request type called IQueryUncommitted with isolation level ReadUncommitted here . The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IHandler<in TRequest> For handlers that do not return any response. IHandler<in TRequest, TResponse> For handlers that have responses. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } } Finally, inject IMediator anywhere in your application, like a controller in WebAPI or a MVC application, and call ProcessAsync method. Check out the implemenation Mediator to know the internals. Example: [Route(\"api/[controller]\")] public class StudentsController : Controller { private readonly IMediator _mediator; public StudentsController(IMediator mediator) { this._mediator = mediator; } [HttpGet] public async Task<IEnumerable<StudentDto>> Get() { var students = await _mediator.ProcessAsync(new GetAllStudentsRequest()); return students; } } Interceptors Every request flows thru a set of built-in interceptors (mentioned below), and the execution of them can be controlled by implementing appropriate marker interfaces. StopwatchInterceptor This interceptor logs the time that a request enters and exits the pipeline. This interceptor is enabled only if the request implements IEnableInterceptor<StopwatchInterceptor> interface. UnitOfWorkInterceptor This interceptor starts a transaction with an isolation level based on the interface like IQuery or ICommand etc., (mentioned above) that the request implements. This interceptor is enabled only if the request implements IEnableInterceptor<UnitOfWorkInterceptor> interface You could create an interceptor by implementing IInterceptor interface, like this . If you want to control the execution of an interceptor based on the incoming request, you can make the request implement IEnableInterceptor<TInterceptor> and add a check something like this: if (!(request is IEnableInterceptor<StopwatchInterceptor>)) return await next.Invoke(request, cancellationToken); Note: Interceptors from all the bolted modules and assemblies must be added explicitly using AddInterceptor<TInterceptor> extension method. Interceptors get executed in the order they're added. Interceptors can be removed using RemoveInterceptor<TInterceptor> extension method. All the interceptors in the pipeline (in other packages) can be removed using RemoveAllInterceptors extension method. However, if this extension method is executed in a registration task and if there is another registration task after your registration task to add interceptors, those interceptors will be added to the pipeline. Interceptors can be added before or after an existing interceptor using Before<TInterceptor> or After<TInterceptor> respectively. Example: boltOnOptions.AddInterceptor<CqrsInterceptor>().Before<UnitOfWorkInterceptor>(); Unit of Work If you use Mediator and implement any of the interfaces like IQuery or ICommand, which in turn implements IEnableInterceptor<UnitOfWorkInterceptor> , you need not worry about starting or committing unit of work, it will be done automatically using UnitOfWorkInterceptor . If you're not using Mediator and if you want to start a unit of work, you could just used .NET's TransactionScope or call Get method in IUnitOfWorkManager by passing UnitOfWorkOptions based on your needs. All that it does is start a new transaction with System.Transactions.TransactionScopeOption.RequiresNew . The default transaction isolation level is IsolationLevel.ReadCommitted . Note: Though it's possible to start a unit of work manually, please try to do avoid it, especially when there is already one, as having more than one unit of work isn't a proper way to build applications. This will be useful only when you want to query a database with an isolation level different from the one started by UnitOfWorkInterceptor . In case if you want to change the default transaction isolation level for all the requests or only certain requests, or if you want to change the TransactionTimeout, you can implement IUnitOfWorkOptionsBuilder like this or inherit UnitOfWorkOptionsBuilder and override the Build method.","title":"Mediator"},{"location":"mediator/#request-response-and-handler","text":"In order to use the Mediator, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. ICommand To create a request that doesn't have any response and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. ICommand<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. IQuery<out TResponse> To create a request with response of type TResponse and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. If BoltOn.Data.EF package is installed and bolted, DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false in DbContextFactory . In case if you want a custom request type with a different isolation level, you could create an interface and customize UnitOfWorkOptionsBuilder by overriding it or by creating a new one. Check out this custom request type called IQueryUncommitted with isolation level ReadUncommitted here . The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IHandler<in TRequest> For handlers that do not return any response. IHandler<in TRequest, TResponse> For handlers that have responses. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } } Finally, inject IMediator anywhere in your application, like a controller in WebAPI or a MVC application, and call ProcessAsync method. Check out the implemenation Mediator to know the internals. Example: [Route(\"api/[controller]\")] public class StudentsController : Controller { private readonly IMediator _mediator; public StudentsController(IMediator mediator) { this._mediator = mediator; } [HttpGet] public async Task<IEnumerable<StudentDto>> Get() { var students = await _mediator.ProcessAsync(new GetAllStudentsRequest()); return students; } }","title":"Request, Response and Handler"},{"location":"mediator/#interceptors","text":"Every request flows thru a set of built-in interceptors (mentioned below), and the execution of them can be controlled by implementing appropriate marker interfaces. StopwatchInterceptor This interceptor logs the time that a request enters and exits the pipeline. This interceptor is enabled only if the request implements IEnableInterceptor<StopwatchInterceptor> interface. UnitOfWorkInterceptor This interceptor starts a transaction with an isolation level based on the interface like IQuery or ICommand etc., (mentioned above) that the request implements. This interceptor is enabled only if the request implements IEnableInterceptor<UnitOfWorkInterceptor> interface You could create an interceptor by implementing IInterceptor interface, like this . If you want to control the execution of an interceptor based on the incoming request, you can make the request implement IEnableInterceptor<TInterceptor> and add a check something like this: if (!(request is IEnableInterceptor<StopwatchInterceptor>)) return await next.Invoke(request, cancellationToken); Note: Interceptors from all the bolted modules and assemblies must be added explicitly using AddInterceptor<TInterceptor> extension method. Interceptors get executed in the order they're added. Interceptors can be removed using RemoveInterceptor<TInterceptor> extension method. All the interceptors in the pipeline (in other packages) can be removed using RemoveAllInterceptors extension method. However, if this extension method is executed in a registration task and if there is another registration task after your registration task to add interceptors, those interceptors will be added to the pipeline. Interceptors can be added before or after an existing interceptor using Before<TInterceptor> or After<TInterceptor> respectively. Example: boltOnOptions.AddInterceptor<CqrsInterceptor>().Before<UnitOfWorkInterceptor>();","title":"Interceptors"},{"location":"mediator/#unit-of-work","text":"If you use Mediator and implement any of the interfaces like IQuery or ICommand, which in turn implements IEnableInterceptor<UnitOfWorkInterceptor> , you need not worry about starting or committing unit of work, it will be done automatically using UnitOfWorkInterceptor . If you're not using Mediator and if you want to start a unit of work, you could just used .NET's TransactionScope or call Get method in IUnitOfWorkManager by passing UnitOfWorkOptions based on your needs. All that it does is start a new transaction with System.Transactions.TransactionScopeOption.RequiresNew . The default transaction isolation level is IsolationLevel.ReadCommitted . Note: Though it's possible to start a unit of work manually, please try to do avoid it, especially when there is already one, as having more than one unit of work isn't a proper way to build applications. This will be useful only when you want to query a database with an isolation level different from the one started by UnitOfWorkInterceptor . In case if you want to change the default transaction isolation level for all the requests or only certain requests, or if you want to change the TransactionTimeout, you can implement IUnitOfWorkOptionsBuilder like this or inherit UnitOfWorkOptionsBuilder and override the Build method.","title":"Unit of Work"},{"location":"optional/","text":"Logging BoltOn uses .NET Core's logger internally, with just a custom adapter to help in unit testing. You could use any logging provider as you wish, or you could inherit BoltOnLogger<TType> and override the logging methods. IQueryUncommitted In case if you want a custom request type which is completely different from IQuery or ICommand in terms of the transaction isolation level or transaction timeout, you could create one something like this: public interface IQueryUncommitted<out TResponse> : IRequest<TResponse>, IEnableUnitOfWorkInterceptor { } And then create a custom interceptor in case if you want to tweak the ChangeTrackerContext, like the one mentioned below and create a custom UnitOfWorkOptionsBuilder to change the transaction isolation level or timeout, like the one mentioned below . And, finally register them like this: serviceCollection.RemoveInterceptor<ChangeTrackerInterceptor>(); serviceCollection.AddInterceptor<CustomChangeTrackerInterceptor>(); serviceCollection.AddTransient<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>(); Interceptor You could create your custom interceptor for change tracking something like this: public class CustomChangeTrackerInterceptor : IInterceptor { private readonly ChangeTrackerContext _changeTrackerContext; public CustomChangeTrackerInterceptor(ChangeTrackerContext changeTrackerContext) { _changeTrackerContext = changeTrackerContext; } public async Task<TResponse> RunAsync<TRequest, TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken, Func<IRequest<TResponse>, CancellationToken, Task<TResponse>> next) where TRequest : IRequest<TResponse> { _changeTrackerContext.IsQueryRequest = request is IQuery<TResponse> || request is IQueryUncommitted<TResponse>; var response = await next(request, cancellationToken); return response; } public void Dispose() { } } UnitOfWorkOptionsBuilder You could create your custom UnitOfWorkOptionsBuilder to change the isolation level and/or transaction timeout based on request type something like this: public class CustomUnitOfWorkOptionsBuilder : IUnitOfWorkOptionsBuilder { private readonly IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> _logger; public CustomUnitOfWorkOptionsBuilder(IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> logger) { _logger = logger; } public UnitOfWorkOptions Build<TResponse>(IRequest<TResponse> request) { IsolationLevel isolationLevel; switch (request) { case ICommand<TResponse> _: case IQuery<TResponse> _: case ICommand _: _logger.Debug(\"Getting isolation level for Command or Query\"); isolationLevel = IsolationLevel.ReadCommitted; break; case IQueryUncommitted<TResponse> _: _logger.Debug(\"Getting isolation level for QueryUncommitted\"); isolationLevel = IsolationLevel.ReadUncommitted; break; default: throw new Exception(\"Request should implement ICommand<> or IQuery<> to enable Unit of Work.\"); } return new UnitOfWorkOptions { IsolationLevel = isolationLevel }; } }","title":"Optional"},{"location":"optional/#logging","text":"BoltOn uses .NET Core's logger internally, with just a custom adapter to help in unit testing. You could use any logging provider as you wish, or you could inherit BoltOnLogger<TType> and override the logging methods.","title":"Logging"},{"location":"optional/#iqueryuncommitted","text":"In case if you want a custom request type which is completely different from IQuery or ICommand in terms of the transaction isolation level or transaction timeout, you could create one something like this: public interface IQueryUncommitted<out TResponse> : IRequest<TResponse>, IEnableUnitOfWorkInterceptor { } And then create a custom interceptor in case if you want to tweak the ChangeTrackerContext, like the one mentioned below and create a custom UnitOfWorkOptionsBuilder to change the transaction isolation level or timeout, like the one mentioned below . And, finally register them like this: serviceCollection.RemoveInterceptor<ChangeTrackerInterceptor>(); serviceCollection.AddInterceptor<CustomChangeTrackerInterceptor>(); serviceCollection.AddTransient<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>();","title":"IQueryUncommitted"},{"location":"optional/#interceptor","text":"You could create your custom interceptor for change tracking something like this: public class CustomChangeTrackerInterceptor : IInterceptor { private readonly ChangeTrackerContext _changeTrackerContext; public CustomChangeTrackerInterceptor(ChangeTrackerContext changeTrackerContext) { _changeTrackerContext = changeTrackerContext; } public async Task<TResponse> RunAsync<TRequest, TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken, Func<IRequest<TResponse>, CancellationToken, Task<TResponse>> next) where TRequest : IRequest<TResponse> { _changeTrackerContext.IsQueryRequest = request is IQuery<TResponse> || request is IQueryUncommitted<TResponse>; var response = await next(request, cancellationToken); return response; } public void Dispose() { } }","title":"Interceptor"},{"location":"optional/#unitofworkoptionsbuilder","text":"You could create your custom UnitOfWorkOptionsBuilder to change the isolation level and/or transaction timeout based on request type something like this: public class CustomUnitOfWorkOptionsBuilder : IUnitOfWorkOptionsBuilder { private readonly IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> _logger; public CustomUnitOfWorkOptionsBuilder(IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> logger) { _logger = logger; } public UnitOfWorkOptions Build<TResponse>(IRequest<TResponse> request) { IsolationLevel isolationLevel; switch (request) { case ICommand<TResponse> _: case IQuery<TResponse> _: case ICommand _: _logger.Debug(\"Getting isolation level for Command or Query\"); isolationLevel = IsolationLevel.ReadCommitted; break; case IQueryUncommitted<TResponse> _: _logger.Debug(\"Getting isolation level for QueryUncommitted\"); isolationLevel = IsolationLevel.ReadUncommitted; break; default: throw new Exception(\"Request should implement ICommand<> or IQuery<> to enable Unit of Work.\"); } return new UnitOfWorkOptions { IsolationLevel = isolationLevel }; } }","title":"UnitOfWorkOptionsBuilder"},{"location":"samples/","text":"In order to run the Samples projects, SQL server and RabbitMq should be configured. If you already have SQL server and RabbitMq installed, please change the appsettings in the BoltOn.Samples.WebApi and BoltOn.Samples.Console projects. If you do not have them installed, you could use docker-compose , or run SQL Server and RabbitMq separately in docker using the commands mentioned below and change the appsettings. docker-compose Navigate to samples folder and execute any of the commands mentioned below. To build and run: docker-compose up -d --build To stop the conainers and remove the images: docker-compose down --rmi local Here is the docker-compose file used. It launches the samples API (http://localhost:5000/), console app (which acts MassTransit event consumer), RabbitMq (management interface http://localhost:5015/) and SQL Server (localhost,5005 with 2 databases - BoltOnSamplesWrite and BoltOnSamplesRead). You could test the StudentsController's actions using Postman or some other API testing tool. Go over CQRS documentation to understand the flow. To run SQL Server separately: docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1' -p 6000:1433 -d microsoft/mssql-server-linux:latest To run RabbitMq separately: docker run -d --name bolton-rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3-management","title":"Samples"},{"location":"samples/#docker-compose","text":"Navigate to samples folder and execute any of the commands mentioned below. To build and run: docker-compose up -d --build To stop the conainers and remove the images: docker-compose down --rmi local Here is the docker-compose file used. It launches the samples API (http://localhost:5000/), console app (which acts MassTransit event consumer), RabbitMq (management interface http://localhost:5015/) and SQL Server (localhost,5005 with 2 databases - BoltOnSamplesWrite and BoltOnSamplesRead). You could test the StudentsController's actions using Postman or some other API testing tool. Go over CQRS documentation to understand the flow. To run SQL Server separately: docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1' -p 6000:1433 -d microsoft/mssql-server-linux:latest To run RabbitMq separately: docker run -d --name bolton-rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3-management","title":"docker-compose"},{"location":"utilities/","text":"IBoltOnClock/BoltOnClock There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IBoltOnClock","title":"Utilities"},{"location":"utilities/#iboltonclockboltonclock","text":"There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IBoltOnClock","title":"IBoltOnClock/BoltOnClock"}]}