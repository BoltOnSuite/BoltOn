{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BoltOn is an open source application framework to help develop simple/modular/extensible/unit-testable .NET applications (Console, MVC, WebAPI, Windows Service etc.,) with reduced boilerplate code. The components are written in such a way that they're modular , thus they can be bolted on with other components and interchanged easily, and hence the name Bolt-On. Installation To install BoltOn in your .NET application, type the following command in the Package Manager Console window: PM> Install-Package BoltOn From CLI: dotnet add package BoltOn Here is the list of NuGet Packages . Configuration After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc(); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostApplicationLifetime lifeTime) { app.UseMvc(); app.ApplicationServices.TightenBolts(); lifetime.ApplicationStopping.Register( () => app.ApplicationServices.LoosenBolts()); } } } To use other BoltOn packages and/or add other assemblies, add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call. BoltOn() This method does the following: Registers all the interfaces in the calling assembly and assemblies passed to BoltOnAssemblies() method with single implementation as trasient. Registers all the Requestor handlers. Note: The order of the methods called is important. If BoltOnEFModule() is called after BoltOnAssemblies(), the assemblies passed to the latter will override the registrations. To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. Use the BoltOnOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules. TightenBolts() This extension method scans all the implementations of IPostRegistrationTask interface in the assemblies passed to BoltOnAssemblies() and executes them. The post registration tasks support constructor injection. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IPostRegistrationTask . Example: public class CustomPostRegistrationTask : IPostRegistrationTask { private readonly SchoolDbContext _schoolDbContext; public CustomPostRegistrationTask(SchoolDbContext schoolDbContext) { _schoolDbContext = schoolDbContext; } public void Run() { _schoolDbContext.Database.EnsureCreated(); _schoolDbContext.Set<Student>().Add(new Student { Id = 1, FirstName = \"a\", LastName = \"b\" }); _schoolDbContext.SaveChanges(); _schoolDbContext.Dispose(); } } LoosenBolts() This extension method scans all the implementations of ICleanupTask interface in the assemblies passed to BoltOnAssemblies() and executes them. This is mainly used to dispose and perform other clean-up tasks. Example: public class CleanupTask : ICleanupTask { private readonly IServiceProvider _serviceProvider; public CleanupTask(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; } public void Run() { var busControl = _serviceProvider.GetService<IBusControl>(); busControl?.Stop(); } }","title":"Introduction"},{"location":"#installation","text":"To install BoltOn in your .NET application, type the following command in the Package Manager Console window: PM> Install-Package BoltOn From CLI: dotnet add package BoltOn Here is the list of NuGet Packages .","title":"Installation"},{"location":"#configuration","text":"After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc(); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostApplicationLifetime lifeTime) { app.UseMvc(); app.ApplicationServices.TightenBolts(); lifetime.ApplicationStopping.Register( () => app.ApplicationServices.LoosenBolts()); } } } To use other BoltOn packages and/or add other assemblies, add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call.","title":"Configuration"},{"location":"#bolton","text":"This method does the following: Registers all the interfaces in the calling assembly and assemblies passed to BoltOnAssemblies() method with single implementation as trasient. Registers all the Requestor handlers. Note: The order of the methods called is important. If BoltOnEFModule() is called after BoltOnAssemblies(), the assemblies passed to the latter will override the registrations. To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. Use the BoltOnOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules.","title":"BoltOn()"},{"location":"#tightenbolts","text":"This extension method scans all the implementations of IPostRegistrationTask interface in the assemblies passed to BoltOnAssemblies() and executes them. The post registration tasks support constructor injection. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IPostRegistrationTask . Example: public class CustomPostRegistrationTask : IPostRegistrationTask { private readonly SchoolDbContext _schoolDbContext; public CustomPostRegistrationTask(SchoolDbContext schoolDbContext) { _schoolDbContext = schoolDbContext; } public void Run() { _schoolDbContext.Database.EnsureCreated(); _schoolDbContext.Set<Student>().Add(new Student { Id = 1, FirstName = \"a\", LastName = \"b\" }); _schoolDbContext.SaveChanges(); _schoolDbContext.Dispose(); } }","title":"TightenBolts()"},{"location":"#loosenbolts","text":"This extension method scans all the implementations of ICleanupTask interface in the assemblies passed to BoltOnAssemblies() and executes them. This is mainly used to dispose and perform other clean-up tasks. Example: public class CleanupTask : ICleanupTask { private readonly IServiceProvider _serviceProvider; public CleanupTask(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; } public void Run() { var busControl = _serviceProvider.GetService<IBusControl>(); busControl?.Stop(); } }","title":"LoosenBolts()"},{"location":"build/","text":"BoltOn uses GitHub Actions for CI and CD. CI involves just building and testing the projects, whereas CD involves building, testing, versioning, packing and publishing to NuGet, and tagging. Though pretty much most of them could be achieved using the GitHub tasks, we are using PowerShell to mainly support performing all the tasks locally. Both the PS scripts ( build.ps1 and publish.ps1 ) use some of the functions in bolton.psm1 . Versioning is done based on Conventional Commits . Here it is: feat: Increments minor version fix: Increments patch version feat! and fix!: Increments major version publish.ps1 script finds all the changed projects in a merge, and increments the version(s) of them based on the commit message. To force changing the versions of projects without making any changes to the project files, scope could be specified in the commit message: Example: feat(BoltOn, BoltOn.Data.EF): test comments Which will increment minor versions of both BoltOn and BoltOn.Data.EF projects, and publish them.","title":"CI & CD"},{"location":"bus/","text":"BoltOn uses MassTransit bus for all the queueing. In order to use the bus, you need do the following: Install BoltOn.Bus.MassTransit NuGet package. Call BoltOnMassTransitModule() in your startup's BoltOn() method. For all the applications that will be just publishing to the queue, configure RabbitMq host and all other settings using MassTransit's extension method for AddMassTransit . Check out this page for the supported configuration. Also refer MassTransit's documentation for all the other supported transports (other than RabbitMq), BoltOnMassTransitModule is transport agnostic. For all the applications that will be consuming messages from the queue, follow all the above steps and then configure BoltOn's BoltOnMassTransitConsumer<TMessage> provided by the above mentioned NuGet package. Finally, inject IBus anywhere in your application and call PublishAsync method to publish your message. Example: Publisher Configuration services.BoltOn(options => { options.BoltOnRabbitMqBusModule(); }); services.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); })); }); Consumer Configuration serviceCollection.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint(host, \"CreateStudent_Queue\", endpoint => { endpoint.Consumer(() => provider.GetService<BoltOnMassTransitConsumer<CreateStudent>>()); }); })); }); You could add an extension method for your transport something like the one mentioned below to configure consumers: public static void BoltOnConsumer<TRequest>(this IRabbitMqBusFactoryConfigurator configurator, IServiceProvider serviceProvider, IRabbitMqHost host, string queueName = null) where TRequest : class, IRequest { configurator.ReceiveEndpoint(host, queueName ?? $\"{typeof(TRequest).Name}_Queue\", endpoint => { endpoint.Consumer(() => serviceProvider.GetService<BoltOnMassTransitConsumer<TRequest>>()); }); } and then call BoltOnConsumer<CreateStudent>(provider, host) Note: As MassTransit had abstracted out the transport like RabbitMq, Azure Service Bus etc., and all the other things very well BoltOn just adds a minor add-on BoltOnMassTransitConsumer<TMessage> to it, which injects IRequestor for processing the message of type TMessage . As the consumer injects IRequestor and uses it for processing the messages, all the messages should implement any of the interfaces mentioned here . Please refer to Requestor documentation to know how to add handlers and its internals. Starting and stopping bus gets taken care by PostRegistrationTask and CleanupTask respectively.","title":"Bus"},{"location":"cache/","text":"BoltOn Cache is just an adapter for .NET Core's IDistributedCache . In order to use it, you have to do the following: Install BoltOn.Cache NuGet package in the host project. Call BoltOnCacheModule() in your startup's BoltOn() method. Install the appropriate NuGet package depending on the IDistributedCache implementations that .NET Core provides - Memory, Redis and SQL Server. Use the appropriate extension methods like AddDistributedMemoryCache or AddDistributedSqlServerCache or AddStackExchangeRedisCache to configure the underlying cache. Finally, inject IBoltOnCache whereever you want in your application. Example: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnCacheModule(); }); serviceCollection.AddStackExchangeRedisCache(options => { options.Configuration = \"localhost:6379\"; }); ICacheResponse and IClearCachedResponse The BoltOnCacheModule comes with 2 other marker interfaces - ICacheResponse and IClearCachedResponse to cache and clear Requestor 's response automatically. It's done using CacheResponseInterceptor . If the request implements ICacheResponse , the cache is checked before entering the pipeline, and if the response exists in the cache, the response is returned without executing the request's handler. If the response is not in the cache, the handler is executed and the response is cached before returning it, so that subsequent requests will be served by the cache. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>>, ICacheResponse { public string CacheKey => \"Students\"; public TimeSpan? SlidingExpiration => TimeSpan.FromHours(2); } If the request implements IClearCachedResponse , the cache is cleared before returning the response, and thus subsequent requests will enter the pipeline. Example: public class CreateStudentRequest : IRequest<Student>, IClearCachedResponse { public string FirstName { get; set; } public string LastName { get; set; } public int StudentTypeId { get; set; } public string CacheKey => \"Students\"; } Note: BoltOnCache uses .NET Core's built-in serializer (System.Text.Json) for serializing cache values to byte array. You can switch the serializer by writing your own implemenation for IBoltOnCacheSerializer and registering the implementation while bootstrapping your application. Check out .NET Core's IDistributedCache documentation to know more about the other configurations and usage.","title":"Cache"},{"location":"cache/#icacheresponse-and-iclearcachedresponse","text":"The BoltOnCacheModule comes with 2 other marker interfaces - ICacheResponse and IClearCachedResponse to cache and clear Requestor 's response automatically. It's done using CacheResponseInterceptor . If the request implements ICacheResponse , the cache is checked before entering the pipeline, and if the response exists in the cache, the response is returned without executing the request's handler. If the response is not in the cache, the handler is executed and the response is cached before returning it, so that subsequent requests will be served by the cache. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>>, ICacheResponse { public string CacheKey => \"Students\"; public TimeSpan? SlidingExpiration => TimeSpan.FromHours(2); } If the request implements IClearCachedResponse , the cache is cleared before returning the response, and thus subsequent requests will enter the pipeline. Example: public class CreateStudentRequest : IRequest<Student>, IClearCachedResponse { public string FirstName { get; set; } public string LastName { get; set; } public int StudentTypeId { get; set; } public string CacheKey => \"Students\"; } Note: BoltOnCache uses .NET Core's built-in serializer (System.Text.Json) for serializing cache values to byte array. You can switch the serializer by writing your own implemenation for IBoltOnCacheSerializer and registering the implementation while bootstrapping your application. Check out .NET Core's IDistributedCache documentation to know more about the other configurations and usage.","title":"ICacheResponse and IClearCachedResponse"},{"location":"cli/","text":"In order to create project templates and other BoltOn components from CLI, execute: dotnet new -i BoltOn.Templates WebAPI To create a .NET Core WebAPI project with BoltOn package bolted: dotnet new bowebapi -n <project_name> -n: Specify the project name. If not specified, the folder name will be used as the project name Handler To create a Requestor handler without response: dotnet new bohandler -n <request_name> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name eg., dotnet new bohandler -n GetStudent The request and the handler will be added in GetStudentHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentRequest : IRequest { } public class GetStudentHandler : IHandler<GetStudentRequest> { public async Task HandleAsync(GetStudentRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } } Handler (with response) To create a Requestor handler with response: dotnet new bohanlder -n <request_name> -r <response_type> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name -r OR --response: Specifiy the type of the response like int, Guid etc. If it's a class type, specify the class name, but you have to create the class eg., dotnet new bohandler -n GetStudentCount -r int The request and the handler will be added in GetStudentsCountHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentsCountRequest : IRequest<int> { } public class GetStudentsCountHandler : IHandler<GetStudentsCountRequest, int> { public async Task<int> HandleAsync(GetStudentsCountRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"Cli"},{"location":"cli/#webapi","text":"To create a .NET Core WebAPI project with BoltOn package bolted: dotnet new bowebapi -n <project_name> -n: Specify the project name. If not specified, the folder name will be used as the project name","title":"WebAPI"},{"location":"cli/#handler","text":"To create a Requestor handler without response: dotnet new bohandler -n <request_name> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name eg., dotnet new bohandler -n GetStudent The request and the handler will be added in GetStudentHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentRequest : IRequest { } public class GetStudentHandler : IHandler<GetStudentRequest> { public async Task HandleAsync(GetStudentRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"Handler"},{"location":"cli/#handler-with-response","text":"To create a Requestor handler with response: dotnet new bohanlder -n <request_name> -r <response_type> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name -r OR --response: Specifiy the type of the response like int, Guid etc. If it's a class type, specify the class name, but you have to create the class eg., dotnet new bohandler -n GetStudentCount -r int The request and the handler will be added in GetStudentsCountHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentsCountRequest : IRequest<int> { } public class GetStudentsCountHandler : IHandler<GetStudentsCountRequest, int> { public async Task<int> HandleAsync(GetStudentsCountRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"Handler (with response)"},{"location":"cqrs/","text":"Command Query Responsibility Segregation (CQRS) pattern derives from the principle Command Query Separation , which states that: [E]very method should either be a command that performs an action, or a query that returns data to the caller, but not both. In other words, Asking a question should not change the answer. \u2013 Wikipedia Command Query Responsibility Separation, or CQRS, takes this principle one step further. CQRS is simply the creation of two objects where there was previously only one. The separation occurs based upon whether the methods are a command or a query (the same definition that is used by Meyer in Command and Query Separation: a command is any method that mutates state and a query is any method that returns a value). \u2013 Greg Young To know more about the CQRS pattern and when to use it, please go over this post . Implementation Most of the CQRS implementations found on the internet mention only about separating the command and the query data stores, but do not mention how to keep the two stores in sync, which is the most challenging part, but BoltOn's CQRS implementation covers it. Data store synchronization could be handled by the following ways: Using a feature like database mirroring (if SQL server), if both the read and writes stores use the same database technology and schemas. By persisting data in the write store and publishing an event to an enterprise bus; updating the read store could be handled by a subscriber to the event. But, this will be consistent only if persisting to the write store and publishing are part of a single transaction. As most of the buses do not support transactions, if write store persistence is successful and publishing to bus fails, the read store would be out of sync. Or, the other way, by publishing event to an enterprise bus and then persisting data in the write store. But, this also relies on transaction, else write store could be out of sync. BoltOn overcomes it using outbox pattern . Event sourcing - there are many libraries supporting event sourcing with CQRS. BoltOn synchronizes data using pub/sub, but without using transactions, it's a slight variation of method 2 mentioned above. The implementation was majorly inspired by these series of posts . In BoltOn, business entity is persisted along with the events raised in the same data store as part of a collection within the entity , and then the persisted events get published to the bus. As events are persisted along with the entity, even if the publish fails, events could be republished later on, provided the business is fine with eventual consistency . In order to implement CQRS using BoltOn, you need to do the following: Install BoltOn.Data.EF NuGet package depending on your read/write data store (currently CQRS is supported only for SQL using EF). Install BoltOn.Bus.MassTransit NuGet package. Refer to Data and Bus documentation to enable the corresponding modules. Enable CQRS by calling BoltOnCqrsModule() in BoltOn() method. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnAssemblies(GetType().Assembly); b.BoltOnEFModule(); b.BoltOnMassTransitBusModule(); b.BoltOnCqrsModule(); }); Configure EF DbContext (if you're using SQL) and MassTransit Bus. Create your domain entity class and inherit BaseCqrsEntity , which will force your entity's Id property to be of type Guid. Create EF mapping configuration class by inheriting BaseCqrsEntityMapping . This takes care of serializing/deserializing EventsToBeProcessed and ProcessedEvents collections. This is done using EF's Value Conversions . Events get triggered from RaiseEvent<TEvent>(TEvent @event) method in the BaseCqrsEntity and they get processed in ProcessEvent<TEvent>(TEvent @event, Action<TEvent> action) . Create your events and inherit CqrsEvent , which implements ICqrsEvent , and which inturn implements Requestor's IRequest , and thus the events can be handled using Requestor . Create your request and handlers, and then use the Requestor to process your request. Please refer to Requestor documentation to create handlers. Register IRepository<TEntity> to EF CQRS Repository . How does it work? The best way to understand the implementation is by looking into BoltOn.Samples.WebApi project's StudentsController and by going thru GET, POST and PUT student endpoints, corresponding requests and their handlers. In this sample we have used only two tables - Student and StudentFlattened in BoltOnSamplesWrite and BoltOnSamplesRead databases respectively. The events that get raised from your entities (that inherit BaseCqrsEntity) get added to EventsToBeProcessed collection. Two entities Student and StudentFlattened inherit BaseCqrsEntity . Student entity is saved in Student table with foreign-key constraint to StudentType table. Commands (aka writes) go to this table. StudentFlattened entity is saved in StudentFlattened table, which is denormalized without any foreign-key constraints. Queries (aka reads) go to this table. Private and internal constructors are added to both the entities. The private constructor is to support EF and the internal constructor is to allow instantiation of the entity with appropriate request object as parameter. Student's internal ctor is called from CreateStudentHandler , which gets invoked by Requestor from StudentController's POST call. StudentCreatedEvent event inherits CqrsEvent . Other properties that are required to create StudentFlattened entity are added. StudentCreatedEvent event is triggered in the ctor by calling the base class' RaiseEvent method. The RaiseEvent method takes care of populating other properties like Id, SourceId, SourceTypeName and CreatedDate. Note: Id, CreatedDate and ProcessedDate properties will be initialized only if we don't initialize them, whereas all the other properties listed above will be overridden by the framework. The triggered events get added to EventsToBeProcessed property only if they're not already present. Here is the Student entity: public class Student : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public int StudentTypeId { get; private set; } private Student() { } internal Student(CreateStudentRequest request, string studentType) { Id = Guid.NewGuid(); FirstName = request.FirstName; LastName = request.LastName; StudentTypeId = request.StudentTypeId; RaiseEvent(new StudentCreatedEvent { StudentId = Id, FirstName = FirstName, LastName = LastName, StudentType = studentType, StudentTypeId = StudentTypeId }); } } IRepository<Student> injected in the CreateStudentHandler is registered to use CqrsRepository<Student> . Please look into the Startup class in the BoltOn.Samples.WebApi project for all the other registrations. When AddAsync of the repository is called in the handler, the repository adds the entity and while saving changes, the events marked for processing are added to a request scoped object called EventBag . If CQRS is enabled in the Startup's BoltOn method, CqrsInterceptor is added to the Requestor pipeline. The intercepor calls EventDispatcher to dispatch events that need to be processed, which inturn publishes events using IBus . You could write your own implementation of IEventDispatcher or IBus if the built-in classes do not satisfy your needs. Even if the dispatcher or the bus fails, the events to be processed will be persisted along with the entity, as the CqrsIntercepor is outside the UnitOfWorkIntercepor , which takes care of committing the transaction. If there are more than one event to be processed and if one fails, all the subsequent events dispatching get aborted, so that the order of the events could be maintained. The MassTransit consumer registered to handle StudentCreatedEvent in the BoltOn.Samples.Console project's Startup class handles the event using StudentCreatedEventHandler . Here is the registration: container.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint(\"StudentCreatedEvent_queue\", ep => { ep.Consumer(() => provider.GetService<BoltOnMassTransitConsumer<StudentCreatedEvent>>()); }); })); }); StudentFlattened's internal ctor is called from StudentCreatedHandler , which gets invoked by Requestor from BoltOnMassTransitConsumer<StudentCreatedEvent> StudentCreatedEvent event is processed in the ctor by calling the base class' ProcessEvent method. The action delegate passed as a parameter to the method is invoked only if the event is not already processed. After invoking the action delegate, the DestinationId and the DestinationTypeName properties are populated and the event is added to the ProcessedEvents collection. The ProcessedEvents get persisted along with the entity and thus the collection prevents events getting re-processed. Here is the StudentFlattened entity: public class StudentFlattened : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public string StudentType { get; private set; } private StudentFlattened() { } internal StudentFlattened(StudentCreatedEvent @event) { ProcessEvent(@event, e => { Id = e.StudentId; FirstName = e.FirstName; LastName = e.LastName; StudentType = e.StudentType; StudentTypeId = e.StudentTypeId; }); } } IRepository<StudentFlattened> injected in the StudentCreatedEventHandler is registered to use CqrsRepository<StudentFlattened> . When AddAsync of the repository is called in the handler, the repository adds the entity and while saving changes using the SaveChanges method, the processed events get persisted along with the entity. Note: By default the events to be processed get purged right after dispatching them, in case if you do not want them to be purged, set CqrsOptions' PurgeEventsToBeProcessed property to false while bootstraping the app. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnAssemblies(GetType().Assembly); b.BoltOnEFModule(); b.BoltOnMassTransitBusModule(); b.BoltOnCqrsModule(o => o.PurgeEventsToBeProcessed = false); }); Purging is done in the CqrsInterceptor using a delegate that gets initialized in the CqrsRepository . The processed events get persisted along with the read entity to mainly maintain idempotency i.e., the events that get dispatched more than once due to queue failure or events to processed purging failure may reach read side consumer more than once, so to prevent it, processed events get persisted so that before processing an event the collection can be checked. But, over a period of time, ProcessedEvents collection could bloat the read entity, so you could set CqrsOptions' PurgeEventsProcessedBefore to a TimeSpan while bootstrapping the application. Say you set it to TimeSpan.FromHours(12), all the events that were persisted before 12 hours will be purged. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnAssemblies(GetType().Assembly); b.BoltOnEFModule(); b.BoltOnMassTransitBusModule(); b.BoltOnCqrsModule(c => c.PurgeEventsProcessedBefore = TimeSpan.FromHours(12)); }); In case if the RabbitMq is down, dispatching will fail but EventsToBeProcessed will get persisted along with the entity; the next time when an event gets raised within the same entity, the failed events will be dispached.","title":"CQRS"},{"location":"cqrs/#implementation","text":"Most of the CQRS implementations found on the internet mention only about separating the command and the query data stores, but do not mention how to keep the two stores in sync, which is the most challenging part, but BoltOn's CQRS implementation covers it. Data store synchronization could be handled by the following ways: Using a feature like database mirroring (if SQL server), if both the read and writes stores use the same database technology and schemas. By persisting data in the write store and publishing an event to an enterprise bus; updating the read store could be handled by a subscriber to the event. But, this will be consistent only if persisting to the write store and publishing are part of a single transaction. As most of the buses do not support transactions, if write store persistence is successful and publishing to bus fails, the read store would be out of sync. Or, the other way, by publishing event to an enterprise bus and then persisting data in the write store. But, this also relies on transaction, else write store could be out of sync. BoltOn overcomes it using outbox pattern . Event sourcing - there are many libraries supporting event sourcing with CQRS. BoltOn synchronizes data using pub/sub, but without using transactions, it's a slight variation of method 2 mentioned above. The implementation was majorly inspired by these series of posts . In BoltOn, business entity is persisted along with the events raised in the same data store as part of a collection within the entity , and then the persisted events get published to the bus. As events are persisted along with the entity, even if the publish fails, events could be republished later on, provided the business is fine with eventual consistency . In order to implement CQRS using BoltOn, you need to do the following: Install BoltOn.Data.EF NuGet package depending on your read/write data store (currently CQRS is supported only for SQL using EF). Install BoltOn.Bus.MassTransit NuGet package. Refer to Data and Bus documentation to enable the corresponding modules. Enable CQRS by calling BoltOnCqrsModule() in BoltOn() method. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnAssemblies(GetType().Assembly); b.BoltOnEFModule(); b.BoltOnMassTransitBusModule(); b.BoltOnCqrsModule(); }); Configure EF DbContext (if you're using SQL) and MassTransit Bus. Create your domain entity class and inherit BaseCqrsEntity , which will force your entity's Id property to be of type Guid. Create EF mapping configuration class by inheriting BaseCqrsEntityMapping . This takes care of serializing/deserializing EventsToBeProcessed and ProcessedEvents collections. This is done using EF's Value Conversions . Events get triggered from RaiseEvent<TEvent>(TEvent @event) method in the BaseCqrsEntity and they get processed in ProcessEvent<TEvent>(TEvent @event, Action<TEvent> action) . Create your events and inherit CqrsEvent , which implements ICqrsEvent , and which inturn implements Requestor's IRequest , and thus the events can be handled using Requestor . Create your request and handlers, and then use the Requestor to process your request. Please refer to Requestor documentation to create handlers. Register IRepository<TEntity> to EF CQRS Repository .","title":"Implementation"},{"location":"cqrs/#how-does-it-work","text":"The best way to understand the implementation is by looking into BoltOn.Samples.WebApi project's StudentsController and by going thru GET, POST and PUT student endpoints, corresponding requests and their handlers. In this sample we have used only two tables - Student and StudentFlattened in BoltOnSamplesWrite and BoltOnSamplesRead databases respectively. The events that get raised from your entities (that inherit BaseCqrsEntity) get added to EventsToBeProcessed collection. Two entities Student and StudentFlattened inherit BaseCqrsEntity . Student entity is saved in Student table with foreign-key constraint to StudentType table. Commands (aka writes) go to this table. StudentFlattened entity is saved in StudentFlattened table, which is denormalized without any foreign-key constraints. Queries (aka reads) go to this table. Private and internal constructors are added to both the entities. The private constructor is to support EF and the internal constructor is to allow instantiation of the entity with appropriate request object as parameter. Student's internal ctor is called from CreateStudentHandler , which gets invoked by Requestor from StudentController's POST call. StudentCreatedEvent event inherits CqrsEvent . Other properties that are required to create StudentFlattened entity are added. StudentCreatedEvent event is triggered in the ctor by calling the base class' RaiseEvent method. The RaiseEvent method takes care of populating other properties like Id, SourceId, SourceTypeName and CreatedDate. Note: Id, CreatedDate and ProcessedDate properties will be initialized only if we don't initialize them, whereas all the other properties listed above will be overridden by the framework. The triggered events get added to EventsToBeProcessed property only if they're not already present. Here is the Student entity: public class Student : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public int StudentTypeId { get; private set; } private Student() { } internal Student(CreateStudentRequest request, string studentType) { Id = Guid.NewGuid(); FirstName = request.FirstName; LastName = request.LastName; StudentTypeId = request.StudentTypeId; RaiseEvent(new StudentCreatedEvent { StudentId = Id, FirstName = FirstName, LastName = LastName, StudentType = studentType, StudentTypeId = StudentTypeId }); } } IRepository<Student> injected in the CreateStudentHandler is registered to use CqrsRepository<Student> . Please look into the Startup class in the BoltOn.Samples.WebApi project for all the other registrations. When AddAsync of the repository is called in the handler, the repository adds the entity and while saving changes, the events marked for processing are added to a request scoped object called EventBag . If CQRS is enabled in the Startup's BoltOn method, CqrsInterceptor is added to the Requestor pipeline. The intercepor calls EventDispatcher to dispatch events that need to be processed, which inturn publishes events using IBus . You could write your own implementation of IEventDispatcher or IBus if the built-in classes do not satisfy your needs. Even if the dispatcher or the bus fails, the events to be processed will be persisted along with the entity, as the CqrsIntercepor is outside the UnitOfWorkIntercepor , which takes care of committing the transaction. If there are more than one event to be processed and if one fails, all the subsequent events dispatching get aborted, so that the order of the events could be maintained. The MassTransit consumer registered to handle StudentCreatedEvent in the BoltOn.Samples.Console project's Startup class handles the event using StudentCreatedEventHandler . Here is the registration: container.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint(\"StudentCreatedEvent_queue\", ep => { ep.Consumer(() => provider.GetService<BoltOnMassTransitConsumer<StudentCreatedEvent>>()); }); })); }); StudentFlattened's internal ctor is called from StudentCreatedHandler , which gets invoked by Requestor from BoltOnMassTransitConsumer<StudentCreatedEvent> StudentCreatedEvent event is processed in the ctor by calling the base class' ProcessEvent method. The action delegate passed as a parameter to the method is invoked only if the event is not already processed. After invoking the action delegate, the DestinationId and the DestinationTypeName properties are populated and the event is added to the ProcessedEvents collection. The ProcessedEvents get persisted along with the entity and thus the collection prevents events getting re-processed. Here is the StudentFlattened entity: public class StudentFlattened : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public string StudentType { get; private set; } private StudentFlattened() { } internal StudentFlattened(StudentCreatedEvent @event) { ProcessEvent(@event, e => { Id = e.StudentId; FirstName = e.FirstName; LastName = e.LastName; StudentType = e.StudentType; StudentTypeId = e.StudentTypeId; }); } } IRepository<StudentFlattened> injected in the StudentCreatedEventHandler is registered to use CqrsRepository<StudentFlattened> . When AddAsync of the repository is called in the handler, the repository adds the entity and while saving changes using the SaveChanges method, the processed events get persisted along with the entity. Note: By default the events to be processed get purged right after dispatching them, in case if you do not want them to be purged, set CqrsOptions' PurgeEventsToBeProcessed property to false while bootstraping the app. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnAssemblies(GetType().Assembly); b.BoltOnEFModule(); b.BoltOnMassTransitBusModule(); b.BoltOnCqrsModule(o => o.PurgeEventsToBeProcessed = false); }); Purging is done in the CqrsInterceptor using a delegate that gets initialized in the CqrsRepository . The processed events get persisted along with the read entity to mainly maintain idempotency i.e., the events that get dispatched more than once due to queue failure or events to processed purging failure may reach read side consumer more than once, so to prevent it, processed events get persisted so that before processing an event the collection can be checked. But, over a period of time, ProcessedEvents collection could bloat the read entity, so you could set CqrsOptions' PurgeEventsProcessedBefore to a TimeSpan while bootstrapping the application. Say you set it to TimeSpan.FromHours(12), all the events that were persisted before 12 hours will be purged. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnAssemblies(GetType().Assembly); b.BoltOnEFModule(); b.BoltOnMassTransitBusModule(); b.BoltOnCqrsModule(c => c.PurgeEventsProcessedBefore = TimeSpan.FromHours(12)); }); In case if the RabbitMq is down, dispatching will fail but EventsToBeProcessed will get persisted along with the entity; the next time when an event gets raised within the same entity, the failed events will be dispached.","title":"How does it work?"},{"location":"data/","text":"Entity You could create an entity by inheriting BaseEntity<TIdType> where TIdType is the type of the Id property. IRepository IRepository interface in the core BoltOn package is abstracted out to keep it agnostic of any particular database, so that the implementation could be changed easily while bootstrapping the application when we switch databases (which rarely happens though). The disadvantage of this abstraction is, we lose certain native features of the underlying database specific features, as it isn't easy to come up with a common IRepository interface to support all the databases. So, please feel free to override the existing implementation or come up with your own implemenation for some of the missing methods. Entity Framework Repository In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create a DbContext by inheriting BaseDbContext<TDbContext> . You could inherit EF's DbContext directy if you're not interested in any of the benefits that BaseDbContext offers. Inherit Repository<TEntity, TDbContext> to create a repository for your entity. All the repository methods accept an optional parameter options, in FindBy methods, if other navigation properties need to be fetched, a collection of expressions can be passed. Example: var includes = new List<Expression<Func<Student, object>>> { s => s.Addresses }; // act var result = repository.FindBy(f => f.Id == 2, includes).FirstOrDefault(); Add all the database columns to entity properties mapping inside a mapping class by implementing IEntityTypeConfiguration<TEntity> interface. The mapping classes will be automatically added to your DbContext if you inherit BaseDbContext<TDbContext> and if they are in the same assembly where the DbContext resides. In case if you do not want all the mapping configuration classes in the assembly to be added, you can override ApplyConfigurations(ModelBuilder modelBuilder) method of BaseDbContext and add the configuration classes manually. Example: // DbContext public class SchoolDbContext : BaseDbContext<SchoolDbContext> { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.Id); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } and register like this: serviceCollection.AddTransient<IRepository<Student>, Repository<Student, SchoolDbContext>>(); If you want to override the Repository class' methods or if you want to add methods, create your own repository, like this: // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(IDbContextFactory dbContextFactory, EventBag eventBag, IBoltOnClock boltOnClock) : base(dbContextFactory, eventBag, boltOnClock) { } } DbContextFactory This factory uses IServiceProvider to resolve DbContexts, and if the request implements IQuery<> , it sets the DbContexts' ChangeTracker.QueryTrackingBehavior to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled to false with the help of ChangeTrackerInterceptor . Note: You could disable this behavior by removing the interceptor from the pipeline using RemoveInterceptor<ChangeTrackerInterceptor> extension method. CosmosDb In order to use CosmosDb, you need do the following: Install BoltOn.Data.CosmosDb NuGet package. Call BoltOnCosmosDbModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create an options class by inheriting BaseCosmosDbOptions class. Use AddCosmosDb extension method to initialize options like URI, AuthorizationKey and Database Name. Inherit Repository<TEntity, TCosmosDbOptions> to create a repository for your entity. All the repository methods accept an optional parameter options. For some of the methods, RequestOptions can be passed and for some FeedOptions can be passed as the options object, take a look at the Repository<TEntity, TCosmosDbOptions> to see the implementation. Example: services.BoltOn(options => { options.BoltOnCosmosDbModule(); }); services.AddCosmosDb<SchoolCosmosDbOptions>(options => { options.Uri = \"<<SPECIFY URI>>\"; options.AuthorizationKey = \"<<SPECIFY AUTHORIZATION KEY>>\"; options.DatabaseName = \"<<DATABASE NAME>>\"; }); public class SchoolCosmosDbOptions : BaseCosmosDbOptions { } // Entity public class Student : BaseEntity<string> { [JsonProperty(\"id\")] public override string Id { get; set; } [JsonProperty(\"studentId\")] public int StudentId { get; set; } public string FirstName { get; set; } } and register like this: serviceCollection.AddTransient<IRepository<Student>, Repository<Student, SchoolCosmosDbOptions>>(); If you want to override the Repository class' methods or if you want to add methods, create your own repository, like this: // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolCosmosDbOptions>, IStudentRepository { public StudentRepository(SchoolCosmosDbOptions options, EventBag eventBag, IBoltOnClock boltOnClock) : base(options, eventBag, boltOnClock) { } } Note: While using any property in CosmosDb query, make sure property name matches exactly as it is in stored in the document collection. Since EF 3.0+ supports CosmosDb, feel free to use EF directly instead of BoltOn.Data.CosmosDb Elasticsearch BoltOn.Data.Elasticsearch uses NEST library internally. In order to use Elasticsearch, you need do the following: Install BoltOn.Data.Elasticsearch NuGet package. Call BoltOnElasticsearchModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create an options class by inheriting BaseElasticsearchOptions class. Use AddElasticsearch extension method to initialize NEST library's ConnectionSettings. Inherit Repository<TEntity, TElasticsearchOptions> to create a repository for your entity. Here is the implementation Repository<TEntity, TElasticsearchOptions> . Example: services.BoltOn(options => { options.BoltOnElasticsearchModule(); }); services.AddElasticsearch<SchoolElasticDbOptions>(options => { options.ConnectionSettings = new Nest.ConnectionSettings(new Uri(\"http://127.0.0.1:9200\")); }); public class SchoolElasticDbOptions : BaseElasticsearchOptions { } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } and register like this: serviceCollection.AddTransient<IRepository<Student>, Repository<Student, SchoolElasticDbOptions>>() Note: The existing FindByAsync doesn't support find by expression, so pass null for the predicate param and NEST's SearchRequest for the options param. Example: var searchRequest = new SearchRequest { Query = new MatchQuery { Field = \"firstName\", Query = \"John\" } }; repository.FindByAsync(null, searchRequest)","title":"Data"},{"location":"data/#entity","text":"You could create an entity by inheriting BaseEntity<TIdType> where TIdType is the type of the Id property.","title":"Entity"},{"location":"data/#irepository","text":"IRepository interface in the core BoltOn package is abstracted out to keep it agnostic of any particular database, so that the implementation could be changed easily while bootstrapping the application when we switch databases (which rarely happens though). The disadvantage of this abstraction is, we lose certain native features of the underlying database specific features, as it isn't easy to come up with a common IRepository interface to support all the databases. So, please feel free to override the existing implementation or come up with your own implemenation for some of the missing methods.","title":"IRepository"},{"location":"data/#entity-framework-repository","text":"In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create a DbContext by inheriting BaseDbContext<TDbContext> . You could inherit EF's DbContext directy if you're not interested in any of the benefits that BaseDbContext offers. Inherit Repository<TEntity, TDbContext> to create a repository for your entity. All the repository methods accept an optional parameter options, in FindBy methods, if other navigation properties need to be fetched, a collection of expressions can be passed. Example: var includes = new List<Expression<Func<Student, object>>> { s => s.Addresses }; // act var result = repository.FindBy(f => f.Id == 2, includes).FirstOrDefault(); Add all the database columns to entity properties mapping inside a mapping class by implementing IEntityTypeConfiguration<TEntity> interface. The mapping classes will be automatically added to your DbContext if you inherit BaseDbContext<TDbContext> and if they are in the same assembly where the DbContext resides. In case if you do not want all the mapping configuration classes in the assembly to be added, you can override ApplyConfigurations(ModelBuilder modelBuilder) method of BaseDbContext and add the configuration classes manually. Example: // DbContext public class SchoolDbContext : BaseDbContext<SchoolDbContext> { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.Id); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } and register like this: serviceCollection.AddTransient<IRepository<Student>, Repository<Student, SchoolDbContext>>(); If you want to override the Repository class' methods or if you want to add methods, create your own repository, like this: // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(IDbContextFactory dbContextFactory, EventBag eventBag, IBoltOnClock boltOnClock) : base(dbContextFactory, eventBag, boltOnClock) { } }","title":"Entity Framework Repository"},{"location":"data/#dbcontextfactory","text":"This factory uses IServiceProvider to resolve DbContexts, and if the request implements IQuery<> , it sets the DbContexts' ChangeTracker.QueryTrackingBehavior to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled to false with the help of ChangeTrackerInterceptor . Note: You could disable this behavior by removing the interceptor from the pipeline using RemoveInterceptor<ChangeTrackerInterceptor> extension method.","title":"DbContextFactory"},{"location":"data/#cosmosdb","text":"In order to use CosmosDb, you need do the following: Install BoltOn.Data.CosmosDb NuGet package. Call BoltOnCosmosDbModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create an options class by inheriting BaseCosmosDbOptions class. Use AddCosmosDb extension method to initialize options like URI, AuthorizationKey and Database Name. Inherit Repository<TEntity, TCosmosDbOptions> to create a repository for your entity. All the repository methods accept an optional parameter options. For some of the methods, RequestOptions can be passed and for some FeedOptions can be passed as the options object, take a look at the Repository<TEntity, TCosmosDbOptions> to see the implementation. Example: services.BoltOn(options => { options.BoltOnCosmosDbModule(); }); services.AddCosmosDb<SchoolCosmosDbOptions>(options => { options.Uri = \"<<SPECIFY URI>>\"; options.AuthorizationKey = \"<<SPECIFY AUTHORIZATION KEY>>\"; options.DatabaseName = \"<<DATABASE NAME>>\"; }); public class SchoolCosmosDbOptions : BaseCosmosDbOptions { } // Entity public class Student : BaseEntity<string> { [JsonProperty(\"id\")] public override string Id { get; set; } [JsonProperty(\"studentId\")] public int StudentId { get; set; } public string FirstName { get; set; } } and register like this: serviceCollection.AddTransient<IRepository<Student>, Repository<Student, SchoolCosmosDbOptions>>(); If you want to override the Repository class' methods or if you want to add methods, create your own repository, like this: // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolCosmosDbOptions>, IStudentRepository { public StudentRepository(SchoolCosmosDbOptions options, EventBag eventBag, IBoltOnClock boltOnClock) : base(options, eventBag, boltOnClock) { } } Note: While using any property in CosmosDb query, make sure property name matches exactly as it is in stored in the document collection. Since EF 3.0+ supports CosmosDb, feel free to use EF directly instead of BoltOn.Data.CosmosDb","title":"CosmosDb"},{"location":"data/#elasticsearch","text":"BoltOn.Data.Elasticsearch uses NEST library internally. In order to use Elasticsearch, you need do the following: Install BoltOn.Data.Elasticsearch NuGet package. Call BoltOnElasticsearchModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create an options class by inheriting BaseElasticsearchOptions class. Use AddElasticsearch extension method to initialize NEST library's ConnectionSettings. Inherit Repository<TEntity, TElasticsearchOptions> to create a repository for your entity. Here is the implementation Repository<TEntity, TElasticsearchOptions> . Example: services.BoltOn(options => { options.BoltOnElasticsearchModule(); }); services.AddElasticsearch<SchoolElasticDbOptions>(options => { options.ConnectionSettings = new Nest.ConnectionSettings(new Uri(\"http://127.0.0.1:9200\")); }); public class SchoolElasticDbOptions : BaseElasticsearchOptions { } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } and register like this: serviceCollection.AddTransient<IRepository<Student>, Repository<Student, SchoolElasticDbOptions>>() Note: The existing FindByAsync doesn't support find by expression, so pass null for the predicate param and NEST's SearchRequest for the options param. Example: var searchRequest = new SearchRequest { Query = new MatchQuery { Field = \"firstName\", Query = \"John\" } }; repository.FindByAsync(null, searchRequest)","title":"Elasticsearch"},{"location":"optional/","text":"Logging BoltOn uses .NET Core's logger internally, with just a custom adapter to mainly support unit testing, as .NET Core's ILogger has only one method and all the other methods are extension methods. You could use any logging provider as you wish, or you could inherit BoltOnLogger<TType> and override the logging methods. IQueryUncommitted In case if you want a custom request type which is completely different from IQuery or ICommand in terms of the transaction isolation level or transaction timeout, you could create one something like this: public interface IQueryUncommitted<out TResponse> : IRequest<TResponse>, IEnableUnitOfWorkInterceptor { } And then create a custom interceptor in case if you want to tweak the ChangeTrackerContext, like the one mentioned below and create a custom UnitOfWorkOptionsBuilder to change the transaction isolation level or timeout, like the one mentioned below . And, finally register them like this: serviceCollection.RemoveInterceptor<ChangeTrackerInterceptor>(); serviceCollection.AddInterceptor<CustomChangeTrackerInterceptor>(); serviceCollection.AddTransient<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>(); Interceptor You could create your custom interceptor for change tracking something like this: public class CustomChangeTrackerInterceptor : IInterceptor { private readonly ChangeTrackerContext _changeTrackerContext; public CustomChangeTrackerInterceptor(ChangeTrackerContext changeTrackerContext) { _changeTrackerContext = changeTrackerContext; } public async Task<TResponse> RunAsync<TRequest, TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken, Func<IRequest<TResponse>, CancellationToken, Task<TResponse>> next) where TRequest : IRequest<TResponse> { _changeTrackerContext.IsQueryRequest = request is IQuery<TResponse> || request is IQueryUncommitted<TResponse>; var response = await next(request, cancellationToken); return response; } public void Dispose() { } } UnitOfWorkOptionsBuilder You could create your custom UnitOfWorkOptionsBuilder to change the isolation level and/or transaction timeout based on request type something like this: public class CustomUnitOfWorkOptionsBuilder : IUnitOfWorkOptionsBuilder { private readonly IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> _logger; public CustomUnitOfWorkOptionsBuilder(IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> logger) { _logger = logger; } public UnitOfWorkOptions Build<TResponse>(IRequest<TResponse> request) { IsolationLevel isolationLevel; switch (request) { case ICommand<TResponse> _: case IQuery<TResponse> _: case ICommand _: _logger.Debug(\"Getting isolation level for Command or Query\"); isolationLevel = IsolationLevel.ReadCommitted; break; case IQueryUncommitted<TResponse> _: _logger.Debug(\"Getting isolation level for QueryUncommitted\"); isolationLevel = IsolationLevel.ReadUncommitted; break; default: throw new Exception(\"Request should implement ICommand<> or IQuery<> to enable Unit of Work.\"); } return new UnitOfWorkOptions { IsolationLevel = isolationLevel }; } }","title":"Optional"},{"location":"optional/#logging","text":"BoltOn uses .NET Core's logger internally, with just a custom adapter to mainly support unit testing, as .NET Core's ILogger has only one method and all the other methods are extension methods. You could use any logging provider as you wish, or you could inherit BoltOnLogger<TType> and override the logging methods.","title":"Logging"},{"location":"optional/#iqueryuncommitted","text":"In case if you want a custom request type which is completely different from IQuery or ICommand in terms of the transaction isolation level or transaction timeout, you could create one something like this: public interface IQueryUncommitted<out TResponse> : IRequest<TResponse>, IEnableUnitOfWorkInterceptor { } And then create a custom interceptor in case if you want to tweak the ChangeTrackerContext, like the one mentioned below and create a custom UnitOfWorkOptionsBuilder to change the transaction isolation level or timeout, like the one mentioned below . And, finally register them like this: serviceCollection.RemoveInterceptor<ChangeTrackerInterceptor>(); serviceCollection.AddInterceptor<CustomChangeTrackerInterceptor>(); serviceCollection.AddTransient<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>();","title":"IQueryUncommitted"},{"location":"optional/#interceptor","text":"You could create your custom interceptor for change tracking something like this: public class CustomChangeTrackerInterceptor : IInterceptor { private readonly ChangeTrackerContext _changeTrackerContext; public CustomChangeTrackerInterceptor(ChangeTrackerContext changeTrackerContext) { _changeTrackerContext = changeTrackerContext; } public async Task<TResponse> RunAsync<TRequest, TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken, Func<IRequest<TResponse>, CancellationToken, Task<TResponse>> next) where TRequest : IRequest<TResponse> { _changeTrackerContext.IsQueryRequest = request is IQuery<TResponse> || request is IQueryUncommitted<TResponse>; var response = await next(request, cancellationToken); return response; } public void Dispose() { } }","title":"Interceptor"},{"location":"optional/#unitofworkoptionsbuilder","text":"You could create your custom UnitOfWorkOptionsBuilder to change the isolation level and/or transaction timeout based on request type something like this: public class CustomUnitOfWorkOptionsBuilder : IUnitOfWorkOptionsBuilder { private readonly IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> _logger; public CustomUnitOfWorkOptionsBuilder(IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> logger) { _logger = logger; } public UnitOfWorkOptions Build<TResponse>(IRequest<TResponse> request) { IsolationLevel isolationLevel; switch (request) { case ICommand<TResponse> _: case IQuery<TResponse> _: case ICommand _: _logger.Debug(\"Getting isolation level for Command or Query\"); isolationLevel = IsolationLevel.ReadCommitted; break; case IQueryUncommitted<TResponse> _: _logger.Debug(\"Getting isolation level for QueryUncommitted\"); isolationLevel = IsolationLevel.ReadUncommitted; break; default: throw new Exception(\"Request should implement ICommand<> or IQuery<> to enable Unit of Work.\"); } return new UnitOfWorkOptions { IsolationLevel = isolationLevel }; } }","title":"UnitOfWorkOptionsBuilder"},{"location":"requestor/","text":"Requestor is the backbone of BoltOn. It follows the Request/Response and Command Message patterns. Since it doesn't depend on any particular framework like WebAPI, MVC etc., and comprises of pure C# classes, its handlers could be added to application/service layer and could be invoked from any .NET application. The main source of inspiration for the Requestor was Agatha , and various other projects like Brighter and MediatR . Request, Response and Handler In order to use the Requestor, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. ICommand To create a request that doesn't have any response and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. ICommand<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. IQuery<out TResponse> To create a request with response of type TResponse and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. If BoltOn.Data.EF package is installed and bolted, DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false in DbContextFactory . In case if you want a custom request type with a different isolation level, you could create an interface and customize UnitOfWorkOptionsBuilder by overriding it or by creating a new one. Check out this custom request type called IQueryUncommitted with isolation level ReadUncommitted here . The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IHandler<in TRequest> For handlers that do not return any response. IHandler<in TRequest, TResponse> For handlers that have responses. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } } To invoke the handler, you need to inject IRequestor anywhere in your application, like a controller in WebAPI or a MVC application, and call ProcessAsync method. Check out the implemenation Requestor to know the internals. Example: [Route(\"api/[controller]\")] public class StudentsController : Controller { private readonly IRequestor _requestor; public StudentsController(IRequestor requestor) { this._requestor = requestor; } [HttpGet] public async Task<IEnumerable<StudentDto>> Get() { var students = await _requestor.ProcessAsync(new GetAllStudentsRequest()); return students; } } Interceptors Every request flows thru a set of built-in interceptors (mentioned below), and the execution of them can be controlled by implementing appropriate marker interfaces. StopwatchInterceptor This interceptor logs the time that a request enters and exits the pipeline. This interceptor is enabled by default as IRequest implements IEnableInterceptor<StopwatchInterceptor> interface. UnitOfWorkInterceptor This interceptor starts a transaction with an isolation level based on the interface like IQuery or ICommand etc., (mentioned above) that the request implements. This interceptor is enabled only if the request implements IEnableInterceptor<UnitOfWorkInterceptor> interface. ICommand and IQuery interfaces implement IEnableInterceptor<UnitOfWorkInterceptor> . You could create an interceptor by implementing IInterceptor interface, like this . If you want to control the execution of an interceptor based on the incoming request, you can make the request implement IEnableInterceptor<TInterceptor> and add a check something like this: if (!(request is IEnableInterceptor<StopwatchInterceptor>)) return await next.Invoke(request, cancellationToken); Note: Interceptors from all the bolted modules and assemblies must be added explicitly using AddInterceptor<TInterceptor> extension method. Interceptors get executed in the order they're added. Interceptors can be removed using RemoveInterceptor<TInterceptor> extension method. All the interceptors in the pipeline (in other packages) can be removed using RemoveAllInterceptors extension method. However, if this extension method is executed in a registration task and if there is another registration task after your registration task to add interceptors, those interceptors will be added to the pipeline. Interceptors can be added before or after an existing interceptor using Before<TInterceptor> or After<TInterceptor> respectively. Example: boltOnOptions.AddInterceptor<CqrsInterceptor>().Before<UnitOfWorkInterceptor>(); Unit of Work If you use Requestor and implement any of the interfaces like IQuery or ICommand, starting or committing unit of work will be done automatically using UnitOfWorkInterceptor , as both IQuery and ICommand implement IEnableInterceptor<UnitOfWorkInterceptor> . If you're not using Requestor and if you want to start a unit of work, you could just use .NET's TransactionScope or call Get method in IUnitOfWorkManager by passing UnitOfWorkOptions with TransactionScopeOption, IsolationLevel and TransactionTimeout set based on your needs. The default transaction isolation level is IsolationLevel.ReadCommitted . The Get method of UnitOfWorkManager can be called only once, an exception will be thrown if it's called again. In case if you want to change the default transaction isolation level of all the requests or only certain requests, or if you want to change the TransactionTimeout, you can implement IUnitOfWorkOptionsBuilder like this or inherit UnitOfWorkOptionsBuilder and override the Build method.","title":"Requestor"},{"location":"requestor/#request-response-and-handler","text":"In order to use the Requestor, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. ICommand To create a request that doesn't have any response and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. ICommand<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. IQuery<out TResponse> To create a request with response of type TResponse and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. If BoltOn.Data.EF package is installed and bolted, DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false in DbContextFactory . In case if you want a custom request type with a different isolation level, you could create an interface and customize UnitOfWorkOptionsBuilder by overriding it or by creating a new one. Check out this custom request type called IQueryUncommitted with isolation level ReadUncommitted here . The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IHandler<in TRequest> For handlers that do not return any response. IHandler<in TRequest, TResponse> For handlers that have responses. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } } To invoke the handler, you need to inject IRequestor anywhere in your application, like a controller in WebAPI or a MVC application, and call ProcessAsync method. Check out the implemenation Requestor to know the internals. Example: [Route(\"api/[controller]\")] public class StudentsController : Controller { private readonly IRequestor _requestor; public StudentsController(IRequestor requestor) { this._requestor = requestor; } [HttpGet] public async Task<IEnumerable<StudentDto>> Get() { var students = await _requestor.ProcessAsync(new GetAllStudentsRequest()); return students; } }","title":"Request, Response and Handler"},{"location":"requestor/#interceptors","text":"Every request flows thru a set of built-in interceptors (mentioned below), and the execution of them can be controlled by implementing appropriate marker interfaces. StopwatchInterceptor This interceptor logs the time that a request enters and exits the pipeline. This interceptor is enabled by default as IRequest implements IEnableInterceptor<StopwatchInterceptor> interface. UnitOfWorkInterceptor This interceptor starts a transaction with an isolation level based on the interface like IQuery or ICommand etc., (mentioned above) that the request implements. This interceptor is enabled only if the request implements IEnableInterceptor<UnitOfWorkInterceptor> interface. ICommand and IQuery interfaces implement IEnableInterceptor<UnitOfWorkInterceptor> . You could create an interceptor by implementing IInterceptor interface, like this . If you want to control the execution of an interceptor based on the incoming request, you can make the request implement IEnableInterceptor<TInterceptor> and add a check something like this: if (!(request is IEnableInterceptor<StopwatchInterceptor>)) return await next.Invoke(request, cancellationToken); Note: Interceptors from all the bolted modules and assemblies must be added explicitly using AddInterceptor<TInterceptor> extension method. Interceptors get executed in the order they're added. Interceptors can be removed using RemoveInterceptor<TInterceptor> extension method. All the interceptors in the pipeline (in other packages) can be removed using RemoveAllInterceptors extension method. However, if this extension method is executed in a registration task and if there is another registration task after your registration task to add interceptors, those interceptors will be added to the pipeline. Interceptors can be added before or after an existing interceptor using Before<TInterceptor> or After<TInterceptor> respectively. Example: boltOnOptions.AddInterceptor<CqrsInterceptor>().Before<UnitOfWorkInterceptor>();","title":"Interceptors"},{"location":"requestor/#unit-of-work","text":"If you use Requestor and implement any of the interfaces like IQuery or ICommand, starting or committing unit of work will be done automatically using UnitOfWorkInterceptor , as both IQuery and ICommand implement IEnableInterceptor<UnitOfWorkInterceptor> . If you're not using Requestor and if you want to start a unit of work, you could just use .NET's TransactionScope or call Get method in IUnitOfWorkManager by passing UnitOfWorkOptions with TransactionScopeOption, IsolationLevel and TransactionTimeout set based on your needs. The default transaction isolation level is IsolationLevel.ReadCommitted . The Get method of UnitOfWorkManager can be called only once, an exception will be thrown if it's called again. In case if you want to change the default transaction isolation level of all the requests or only certain requests, or if you want to change the TransactionTimeout, you can implement IUnitOfWorkOptionsBuilder like this or inherit UnitOfWorkOptionsBuilder and override the Build method.","title":"Unit of Work"},{"location":"samples/","text":"In order to run the Samples projects, SQL server, RabbitMq and Redis should be configured. If you already have SQL server, RabbitMq and Redis installed, please change the appsettings in the BoltOn.Samples.WebApi and BoltOn.Samples.Console projects. If you do not have them installed, you could use docker-compose , or run SQL Server, RabbitMq and Redis separately in docker using the commands mentioned below and change the appsettings. docker-compose Navigate to samples folder and execute any of the commands mentioned below. To build and run: docker-compose up -d --build To stop the conainers and remove the images: docker-compose down --rmi local Here is the docker-compose file used. It launches the samples API (http://localhost:5000/), console app (which acts MassTransit event consumer), RabbitMq (management interface http://localhost:5015/) and SQL Server (localhost,5005 with 2 databases - BoltOnSamplesWrite and BoltOnSamplesRead). You could test the StudentsController's actions using Postman or some other API testing tool. Go over CQRS documentation to understand the flow. To run SQL Server separately: docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1' -p 6000:1433 -d microsoft/mssql-server-linux:latest To run RabbitMq separately: docker run -d --name bolton-rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3-management To run Redis separately: docker run -d -p 6379:6379 --name redis-local redis OR To run all the above containers: docker-compose -f docker-compose-local.yml up -d","title":"Samples"},{"location":"samples/#docker-compose","text":"Navigate to samples folder and execute any of the commands mentioned below. To build and run: docker-compose up -d --build To stop the conainers and remove the images: docker-compose down --rmi local Here is the docker-compose file used. It launches the samples API (http://localhost:5000/), console app (which acts MassTransit event consumer), RabbitMq (management interface http://localhost:5015/) and SQL Server (localhost,5005 with 2 databases - BoltOnSamplesWrite and BoltOnSamplesRead). You could test the StudentsController's actions using Postman or some other API testing tool. Go over CQRS documentation to understand the flow. To run SQL Server separately: docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1' -p 6000:1433 -d microsoft/mssql-server-linux:latest To run RabbitMq separately: docker run -d --name bolton-rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3-management To run Redis separately: docker run -d -p 6379:6379 --name redis-local redis OR To run all the above containers: docker-compose -f docker-compose-local.yml up -d","title":"docker-compose"},{"location":"utilities/","text":"IBoltOnClock/BoltOnClock There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IBoltOnClock","title":"Utilities"},{"location":"utilities/#iboltonclockboltonclock","text":"There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IBoltOnClock","title":"IBoltOnClock/BoltOnClock"}]}