{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BoltOn is an open source framework to build any .NET application like Console, MVC, WebAPI, Windows Service etc., with proper separation of concerns. Installation There are a couple of packages for BoltOn available on NuGet. To install BoltOn in your .NET application, type the following command into the Package Manager Console window: PM> Install-Package BoltOn Configuration After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseMvc(); app.ApplicationServices.TightenBolts(); } } } To use other BoltOn packages and/or add other assemblies, you can add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call. BoltOn() This method does the following: It groups the executing assembly, all the assemblies of the other modules and the assemblies passed to BoltOnAssemblies() to a collection, sorts them based on the assembly dependencies, and finally scans for all the classes that implement IRegistrationTask and executes them in the order of the assembly dependencies. The assemblies collection can be accessed from RegistrationTaskContext and PostRegistrationTaskContext of the registration tasks. A built-in registration task called BoltOnRegistrationTask registers all the interfaces with single implementation as trasient. Custom registrations: To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. For all the other registration scopes like scoped or singleton, or to register interfaces with more than one implementations, implement IRegistrationTask and use the context.Container (which is of type IServicesCollection ) to register them. Example: public class CustomRegistrationTask : IRegistrationTask { public void Run(RegistrationTaskContext context) { var container = context.Container; container.AddSingleton<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>(); container.AddScoped<ITestService, TestService>(); } } Note: Use the BoltOnOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules. TightenBolts() This extension method scans all the IPostRegistrationTask in the assembly collection formed by BoltOn() and executes them. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IPostRegistrationTask . Example: public class CustomPostRegistrationTask : IPostRegistrationTask { public void Run(PostRegistrationTaskContext context) { var serviceProvider = context.ServiceProvider; var schoolDbContext = serviceProvider.GetService<TestDbContext>(); testDbContext.Database.EnsureCreated(); } } Cleanup BoltOn internally uses a class called Bootstrapper to invoke all the registration and post registration tasks, and when it gets disposed, it calls cleanup tasks in all the modules. It's basically done by scanning all the ICleanupTask in the assembly collection formed by BoltOn() and executing them. The cleanup tasks can be invoked on demand using BoltOnAppCleaner .","title":"Introduction"},{"location":"#installation","text":"There are a couple of packages for BoltOn available on NuGet. To install BoltOn in your .NET application, type the following command into the Package Manager Console window: PM> Install-Package BoltOn","title":"Installation"},{"location":"#configuration","text":"After installing the package, call BoltOn() and TightenBolts() extension methods in ConfigureServices() and Configure() methods respectively. namespace BoltOn.Samples.WebApi { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2); services.BoltOn(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseMvc(); app.ApplicationServices.TightenBolts(); } } } To use other BoltOn packages and/or add other assemblies, you can add them using options: services.BoltOn(options => { options.BoltOnEFModule(); options.BoltOnAssemblies(typeof(PingHandler).Assembly); }); Note: BoltOn uses .NET core's dependency injection internally. In case if you want to use any other DI framework, you can configure it after the BoltOn() call.","title":"Configuration"},{"location":"#bolton","text":"This method does the following: It groups the executing assembly, all the assemblies of the other modules and the assemblies passed to BoltOnAssemblies() to a collection, sorts them based on the assembly dependencies, and finally scans for all the classes that implement IRegistrationTask and executes them in the order of the assembly dependencies. The assemblies collection can be accessed from RegistrationTaskContext and PostRegistrationTaskContext of the registration tasks. A built-in registration task called BoltOnRegistrationTask registers all the interfaces with single implementation as trasient. Custom registrations: To exclude classes from registration, decorate them with [ExcludeFromRegistration] attribute. For all the other registration scopes like scoped or singleton, or to register interfaces with more than one implementations, implement IRegistrationTask and use the context.Container (which is of type IServicesCollection ) to register them. Example: public class CustomRegistrationTask : IRegistrationTask { public void Run(RegistrationTaskContext context) { var container = context.Container; container.AddSingleton<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>(); container.AddScoped<ITestService, TestService>(); } } Note: Use the BoltOnOptions' extension method like BoltOnEFModule to attach the other modules. Each and every module calls other extension methods to attach their own dependent modules.","title":"BoltOn()"},{"location":"#tightenbolts","text":"This extension method scans all the IPostRegistrationTask in the assembly collection formed by BoltOn() and executes them. To run any task that involves resolving dependencies, like seeding data using any of the registered DbContexts, implement IPostRegistrationTask . Example: public class CustomPostRegistrationTask : IPostRegistrationTask { public void Run(PostRegistrationTaskContext context) { var serviceProvider = context.ServiceProvider; var schoolDbContext = serviceProvider.GetService<TestDbContext>(); testDbContext.Database.EnsureCreated(); } }","title":"TightenBolts()"},{"location":"#cleanup","text":"BoltOn internally uses a class called Bootstrapper to invoke all the registration and post registration tasks, and when it gets disposed, it calls cleanup tasks in all the modules. It's basically done by scanning all the ICleanupTask in the assembly collection formed by BoltOn() and executing them. The cleanup tasks can be invoked on demand using BoltOnAppCleaner .","title":"Cleanup"},{"location":"bus/","text":"BoltOn uses MassTransit bus for all the queueing. In order to use the bus, you need do the following: Install BoltOn.Bus.MassTransit NuGet package. Call BoltOnMassTransitModule() in your startup's BoltOn() method. For all the applications that will be just publishing to the queue, configure RabbitMq host and all other settings using MassTransit's extension method for AddMassTransit . Check out this page for the supported configuration. Also refer MassTransit's documentation for all the other supported transports (other than RabbitMq), BoltOnMassTransitModule is transport agnostic. For all the applications that will be consuming messages from the queue, follow all the above steps and then configure BoltOn's BoltOnMassTransitConsumer<TMessage> provided by the above mentioned NuGet package. Finally, inject IBus anywhere in your application and call PublishAsync method to publish your message. Example: Publisher Configuration services.BoltOn(options => { options.BoltOnRabbitMqBusModule(); }); services.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); })); }); Consumer Configuration serviceCollection.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint(host, \"CreateStudent_Queue\", endpoint => { endpoint.Consumer(() => provider.GetService<BoltOnMassTransitConsumer<CreateStudent>>()); }); })); }); You could add an extension method for your transport something like the one mentioned below to configure consumers: public static void BoltOnConsumer<TRequest>(this IRabbitMqBusFactoryConfigurator configurator, IServiceProvider serviceProvider, IRabbitMqHost host, string queueName = null) where TRequest : class, IRequest { configurator.ReceiveEndpoint(host, queueName ?? $\"{typeof(TRequest).Name}_Queue\", endpoint => { endpoint.Consumer(() => serviceProvider.GetService<BoltOnMassTransitConsumer<TRequest>>()); }); } and then call BoltOnConsumer<CreateStudent>(provider, host) Note: As MassTransit had abstracted out the transport like RabbitMq, Azure Service Bus etc., and all the other things very well BoltOn just adds a minor add-on BoltOnMassTransitConsumer<TMessage> to it, which injects IMediator for processing the message of type TMessage . As the consumer injects IMediator and uses it for processing the messages, all the messages should implement any of the interfaces mentioned here . Please refer to Mediator documentation to know how to add handlers and its internals. Starting and stopping bus gets taken care by PostRegistrationTask and CleanupTask respectively.","title":"Bus"},{"location":"cli/","text":"In order to create project templates and other BoltOn components from CLI, install BoltOn.Templates NuGet Package. WebAPI To create a .NET Core WebAPI project with BoltOn package bolted: dotnet new bowebapi -n <project_name> -n: Specify the project name. If not specified, the folder name will be used as the project name Handler To create a Mediator handler without response: dotnet new bohandler -n <request_name> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name eg., dotnet new bohandler -n GetStudent The request and the handler will be added in GetStudentHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentRequest : IRequest { } public class GetStudentHandler : IHandler<GetStudentRequest> { public async Task HandleAsync(GetStudentRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } } Handler (with response) To create a Mediator handler with response: dotnet new bohanlder -n <request_name> -r <response_type> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name -r OR --response: Specifiy the type of the response like int, Guid etc. If it's a class type, specify the class name, but you have to create the class eg., dotnet new bohandler -n GetStudentCount -r int The request and the handler will be added in GetStudentsCountHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentsCountRequest : IRequest<int> { } public class GetStudentsCountHandler : IHandler<GetStudentsCountRequest, int> { public async Task<int> HandleAsync(GetStudentsCountRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"CLI"},{"location":"cli/#webapi","text":"To create a .NET Core WebAPI project with BoltOn package bolted: dotnet new bowebapi -n <project_name> -n: Specify the project name. If not specified, the folder name will be used as the project name","title":"WebAPI"},{"location":"cli/#handler","text":"To create a Mediator handler without response: dotnet new bohandler -n <request_name> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name eg., dotnet new bohandler -n GetStudent The request and the handler will be added in GetStudentHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentRequest : IRequest { } public class GetStudentHandler : IHandler<GetStudentRequest> { public async Task HandleAsync(GetStudentRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"Handler"},{"location":"cli/#handler-with-response","text":"To create a Mediator handler with response: dotnet new bohanlder -n <request_name> -r <response_type> -n: Specify the request name without Request suffix. If not specified, the folder name will be used as the handler name -r OR --response: Specifiy the type of the response like int, Guid etc. If it's a class type, specify the class name, but you have to create the class eg., dotnet new bohandler -n GetStudentCount -r int The request and the handler will be added in GetStudentsCountHandler.cs file inside Handlers folder (Handlers folder will be created if it doesn't exist). namespace Handlers { public class GetStudentsCountRequest : IRequest<int> { } public class GetStudentsCountHandler : IHandler<GetStudentsCountRequest, int> { public async Task<int> HandleAsync(GetStudentsCountRequest request, CancellationToken cancellationToken) { throw new NotImplementedException(); } } }","title":"Handler (with response)"},{"location":"cqrs/","text":"The Command Query Responsibility Segregation (CQRS) implementation in this framework was majorly inspired by these series of posts . To understand more about the CQRS pattern and when to use it, please go over this post . In order to implement CQRS, you need to do the following: Install BoltOn.Data.EF (soon support for CosmosDb will be added) NuGet package. Install BoltOn.Bus.MassTransit NuGet package. Refer to Data and Bus documentation to enable the corresponding modules. Enable CQRS by calling BoltOnCqrsModule() in BoltOn() method. Like this: var serviceCollection = new ServiceCollection(); serviceCollection.BoltOn(b => { b.BoltOnAssemblies(GetType().Assembly); b.BoltOnEFModule(); b.BoltOnMassTransitBusModule(); b.BoltOnCqrsModule(); }); Configure EF DbContext and MassTransit Bus. Create your domain entity class by inheriting BaseCqrsEntity , and which will force your entity's Id property to be of type Guid. Create EF mapping configuration class by inheriting BaseCqrsEntityMapping . This takes care of serializing and converting string to bytes while saving, and converting bytes to string deserializing while retrieving. This is done using EF's Value Conversions . Events get triggered from RaiseEvent<TEvent>(TEvent @event) method in the BaseCqrsEntity and they get processed in ProcessEvent<TEvent>(TEvent @event, Action<TEvent> action) . Events must inherit CqrsEvent , which implements ICqrsEvent , and which inturn implements Mediator's IRequest , and thus the events can be handled using Mediator . Create your request and handlers, and then use the Mediator to process your request. Please refer to Mediator documentation to create handlers. Register IRepository<TEntity> to EF Repository, it's this class . Implementation Sample The best way to understand the implementation is by looking into BoltOn.Samples.WebApi project's StudentsController and by going thru GET, POST and PUT student endpoints, corresponding requests and their handlers. Though separate databases could be used for commands and queries i.e., writes and reads respectively, in this sample we have used only one database (which could change when repositories for other databases are implemented) but different tables. Two entities Student and StudentFlattened are created by inheriting BaseCqrsEntity . Student entity is saved in Student table with foreign-key constraint to StudentType table. Commands (aka writes) go to this table. StudentFlattened entity is saved in StudentFlattened table, which is denormalized without any foreign-key constraints. Queries (aka reads) go to this table. Private and internal constructors are added to both the entities. The private constructor is to support EF and the internal constructor is to allow instantiation of the entity with appropriate request object as parameter. Student's internal ctor is called from CreateStudentHandler , which gets invoked by Mediator from StudentController's POST call. StudentCreatedEvent event is created by inheriting CqrsEvent . Other properties that are required to create StudentFlattened entity are added. As StudentFlattened is denormalized, only StudentType is added to it and not the StudentTypeId. StudentCreatedEvent event is triggered in the ctor by calling the base class' RaiseEvent method. The RaiseEvent method takes care of populating other properties like Id, SourceId, SourceTypeName and CreatedDate. Note: Id property will be initialized only if we don't initialize it, whereas all the other properties listed above will be overridden by the framework. The triggered event gets marked for processing by setting the CreatedDate property to null, and it gets added to EventsToBeProcessed property only if it's not already present. Here is the internal ctor of Student entity: public class Student : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public int StudentTypeId { get; private set; } private Student() { } internal Student(CreateStudentRequest request, string studentType) { Id = Guid.NewGuid(); FirstName = request.FirstName; LastName = request.LastName; StudentTypeId = request.StudentTypeId; RaiseEvent(new StudentCreatedEvent { StudentId = Id, FirstName = FirstName, LastName = LastName, StudentType = studentType }); } } IRepository<Student> injected in the CreateStudentHandler is registered to use Repository<Student> . Please look into the RegistrationTask class in the BoltOn.Samples.WebApi project for all the other registrations. When AddAsync of the repository is called in the handler, the repository adds the entity and on while saving changes using the SaveChanges method, the events marked for processing are added to a request scoped object called EventBag , right after the CreatedDate property is initialized. Note: If CQRS is enabled in the Startup's BoltOn method, CqrsInterceptor is added to the Mediator pipeline. The intercepor calls EventDispatcher to dispatch events that need to be processed, which inturn publishes events using IBus . Even if the dispatcher or the bus fails, the events to be processed will be persisted along with the entity, as the CqrsIntercepor is after the UnitOfWorkIntercepor , which takes care of committing the transaction. The events that get persisted with the entity but not dispatched will be processed the next time the entity is updated. If there are more than one event to be processed and if one or more fails, it will still dispatch the other events. A MassTransit consumer is registered to handle StudentCreatedEvent in the BoltOn.Samples.Console project's RegistrationTask class, and the consumer inturn calls StudentCreatedEventHandler Like this: container.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint(\"StudentCreatedEvent_queue\", ep => { ep.Consumer(() => provider.GetService<BoltOnMassTransitConsumer<StudentCreatedEvent>>()); }); })); }); StudentFlattened's internal ctor is called from StudentCreatedHandler , which gets invoked by Mediator from BoltOnMassTransitConsumer<StudentCreatedEvent> StudentCreatedEvent event is processed in the ctor by calling the base class' ProcessEvent method. The action delegate passed as a parameter to the method is invoked only if the event is not already processed. After invoking the action delegate, the DestinationTypeName property is populated and the event is added to the ProcessedEvents collection. The ProcessedEvents get persisted along with the entity and thus the collection prevents events getting re-processed. Here is the internal ctor of StudentFlattened entity: public class StudentFlattened : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public string StudentType { get; private set; } private StudentFlattened() { } internal StudentFlattened(StudentCreatedEvent @event) { ProcessEvent(@event, e => { Id = e.StudentId; FirstName = e.FirstName; LastName = e.LastName; StudentType = e.StudentType; }); } } IRepository<StudentFlattened> injected in the StudentCreatedEventHandler is registered to use Repository<StudentFlattened> . When AddAsync of the repository is called in the handler, the repository adds the entity and on while saving changes using the SaveChanges method, the processed events' ProcessedDate is populated and persisted. CQRS is implemented even for Student update functionality, so follow the PUT in StudentsController, and UpdateStudentHandler and StudentUpdatedEventHandler handlers.","title":"CQRS"},{"location":"cqrs/#implementation-sample","text":"The best way to understand the implementation is by looking into BoltOn.Samples.WebApi project's StudentsController and by going thru GET, POST and PUT student endpoints, corresponding requests and their handlers. Though separate databases could be used for commands and queries i.e., writes and reads respectively, in this sample we have used only one database (which could change when repositories for other databases are implemented) but different tables. Two entities Student and StudentFlattened are created by inheriting BaseCqrsEntity . Student entity is saved in Student table with foreign-key constraint to StudentType table. Commands (aka writes) go to this table. StudentFlattened entity is saved in StudentFlattened table, which is denormalized without any foreign-key constraints. Queries (aka reads) go to this table. Private and internal constructors are added to both the entities. The private constructor is to support EF and the internal constructor is to allow instantiation of the entity with appropriate request object as parameter. Student's internal ctor is called from CreateStudentHandler , which gets invoked by Mediator from StudentController's POST call. StudentCreatedEvent event is created by inheriting CqrsEvent . Other properties that are required to create StudentFlattened entity are added. As StudentFlattened is denormalized, only StudentType is added to it and not the StudentTypeId. StudentCreatedEvent event is triggered in the ctor by calling the base class' RaiseEvent method. The RaiseEvent method takes care of populating other properties like Id, SourceId, SourceTypeName and CreatedDate. Note: Id property will be initialized only if we don't initialize it, whereas all the other properties listed above will be overridden by the framework. The triggered event gets marked for processing by setting the CreatedDate property to null, and it gets added to EventsToBeProcessed property only if it's not already present. Here is the internal ctor of Student entity: public class Student : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public int StudentTypeId { get; private set; } private Student() { } internal Student(CreateStudentRequest request, string studentType) { Id = Guid.NewGuid(); FirstName = request.FirstName; LastName = request.LastName; StudentTypeId = request.StudentTypeId; RaiseEvent(new StudentCreatedEvent { StudentId = Id, FirstName = FirstName, LastName = LastName, StudentType = studentType }); } } IRepository<Student> injected in the CreateStudentHandler is registered to use Repository<Student> . Please look into the RegistrationTask class in the BoltOn.Samples.WebApi project for all the other registrations. When AddAsync of the repository is called in the handler, the repository adds the entity and on while saving changes using the SaveChanges method, the events marked for processing are added to a request scoped object called EventBag , right after the CreatedDate property is initialized. Note: If CQRS is enabled in the Startup's BoltOn method, CqrsInterceptor is added to the Mediator pipeline. The intercepor calls EventDispatcher to dispatch events that need to be processed, which inturn publishes events using IBus . Even if the dispatcher or the bus fails, the events to be processed will be persisted along with the entity, as the CqrsIntercepor is after the UnitOfWorkIntercepor , which takes care of committing the transaction. The events that get persisted with the entity but not dispatched will be processed the next time the entity is updated. If there are more than one event to be processed and if one or more fails, it will still dispatch the other events. A MassTransit consumer is registered to handle StudentCreatedEvent in the BoltOn.Samples.Console project's RegistrationTask class, and the consumer inturn calls StudentCreatedEventHandler Like this: container.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); cfg.ReceiveEndpoint(\"StudentCreatedEvent_queue\", ep => { ep.Consumer(() => provider.GetService<BoltOnMassTransitConsumer<StudentCreatedEvent>>()); }); })); }); StudentFlattened's internal ctor is called from StudentCreatedHandler , which gets invoked by Mediator from BoltOnMassTransitConsumer<StudentCreatedEvent> StudentCreatedEvent event is processed in the ctor by calling the base class' ProcessEvent method. The action delegate passed as a parameter to the method is invoked only if the event is not already processed. After invoking the action delegate, the DestinationTypeName property is populated and the event is added to the ProcessedEvents collection. The ProcessedEvents get persisted along with the entity and thus the collection prevents events getting re-processed. Here is the internal ctor of StudentFlattened entity: public class StudentFlattened : BaseCqrsEntity { public string FirstName { get; private set; } public string LastName { get; private set; } public string StudentType { get; private set; } private StudentFlattened() { } internal StudentFlattened(StudentCreatedEvent @event) { ProcessEvent(@event, e => { Id = e.StudentId; FirstName = e.FirstName; LastName = e.LastName; StudentType = e.StudentType; }); } } IRepository<StudentFlattened> injected in the StudentCreatedEventHandler is registered to use Repository<StudentFlattened> . When AddAsync of the repository is called in the handler, the repository adds the entity and on while saving changes using the SaveChanges method, the processed events' ProcessedDate is populated and persisted. CQRS is implemented even for Student update functionality, so follow the PUT in StudentsController, and UpdateStudentHandler and StudentUpdatedEventHandler handlers.","title":"Implementation Sample"},{"location":"data/","text":"Entity You could create an entity by inheriting BaseEntity<TIdType> where TIdType is the type of the Id property. Entity Framework Repository The core BoltOn package has only the IRepository interface, which could be used in your domain layer if you're into Domain Driven Design. In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create a DbContext by inheriting BaseDbContext<TDbContext> . You could inherit EF's DbContext directy if you're not interested in any of the benefits that BaseDbContext offers. Inherit Repository<TEntity, TDbContext> to create a repository for your entity. All the repository methods accept an optional parameter options, in FindBy methods, if other navigation properties need to be fetched, a collection of expressions can be passed. Example: var includes = new List<Expression<Func<Student, object>>> { s => s.Addresses }; // act var result = repository.FindBy(f => f.Id == 2, includes).FirstOrDefault(); Add all the database columns to entity properties mapping inside a mapping class by implementing IEntityTypeConfiguration<TEntity> interface. The mapping classes will be automatically added to your DbContext if you inherit BaseDbContext<TDbContext> and if they are in the same assembly where the DbContext resides. Example: // DbContext public class SchoolDbContext : BaseDbContext<SchoolDbContext> { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.Id); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(IDbContextFactory dbContextFactory, EventBag eventBag, IBoltOnClock boltOnClock) : base(dbContextFactory, eventBag, boltOnClock) { } } Note: Create your own repository like StudentRepository only if you want to override the Repository class' methods or if you want to add methods, else just register IRepository<Student> to Repository<Student, SchoolDbContext> DbContextFactory This factory uses IServiceProvider to resolve DbContexts, and if the request implements IQuery<> , it sets the DbContexts' ChangeTracker.QueryTrackingBehavior to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled to false with the help of MediatorContextInterceptor . Note: You could disable this behavior by removing the interceptor from the pipeline using RemoveInterceptor<TInterceptor> extension method. CosmosDb In order to use CosmosDb, you need do the following: Install BoltOn.Data.CosmosDb NuGet package. Call BoltOnCosmosDbModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create an options class by inheriting BaseCosmosDbOptions class. Use AddCosmosDb extension method to initialize options like URI, AuthorizationKey and Database Name. Inherit Repository<TEntity, TCosmosDbOptions> to create a repository for your entity. All the repository methods accept an optional parameter options. For some of the methods, RequestOptions can be passed and for some FeedOptions can be passed as the options object, take a look at the Repository<TEntity, TCosmosDbOptions> to see the implementation. Example: services.BoltOn(options => { options.BoltOnCosmosDbModule(); }); services.AddCosmosDb<SchoolCosmosDbOptions>(options => { options.Uri = \"<<SPECIFY URI>>\"; options.AuthorizationKey = \"<<SPECIFY AUTHORIZATION KEY>>\"; options.DatabaseName = \"<<DATABASE NAME>>\"; }); public class SchoolCosmosDbOptions : BaseCosmosDbOptions { } // Entity public class Student : BaseEntity<string> { [JsonProperty(\"id\")] public override string Id { get; set; } [JsonProperty(\"studentId\")] public int StudentId { get; set; } public string FirstName { get; set; } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolCosmosDbOptions>, IStudentRepository { public StudentRepository(SchoolCosmosDbOptions options, EventBag eventBag, IBoltOnClock boltOnClock) : base(options, eventBag, boltOnClock) { } } Note: Create your own repository like StudentRepository only if you want to override the Repository class' methods or if you want to add methods, else just register IRepository<Student> to Repository<Student, SchoolCosmosDbOptions> While using any property in CosmosDb query, make sure property name matches exactly as it is in stored in the document collection.","title":"Data"},{"location":"data/#entity","text":"You could create an entity by inheriting BaseEntity<TIdType> where TIdType is the type of the Id property.","title":"Entity"},{"location":"data/#entity-framework-repository","text":"The core BoltOn package has only the IRepository interface, which could be used in your domain layer if you're into Domain Driven Design. In order to use Entity Framework implementation of the repository, you need to do the following: Install BoltOn.Data.EF NuGet package. Call BoltOnEFModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create a DbContext by inheriting BaseDbContext<TDbContext> . You could inherit EF's DbContext directy if you're not interested in any of the benefits that BaseDbContext offers. Inherit Repository<TEntity, TDbContext> to create a repository for your entity. All the repository methods accept an optional parameter options, in FindBy methods, if other navigation properties need to be fetched, a collection of expressions can be passed. Example: var includes = new List<Expression<Func<Student, object>>> { s => s.Addresses }; // act var result = repository.FindBy(f => f.Id == 2, includes).FirstOrDefault(); Add all the database columns to entity properties mapping inside a mapping class by implementing IEntityTypeConfiguration<TEntity> interface. The mapping classes will be automatically added to your DbContext if you inherit BaseDbContext<TDbContext> and if they are in the same assembly where the DbContext resides. Example: // DbContext public class SchoolDbContext : BaseDbContext<SchoolDbContext> { public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options) { } } // Entity public class Student : BaseEntity<int> { public string FirstName { get; set; } public string LastName { get; set; } } // Mapping public class StudentMapping : IEntityTypeConfiguration<Student> { public void Configure(EntityTypeBuilder<Student> builder) { builder .ToTable(\"Student\") .HasKey(k => k.Id); builder .Property(p => p.Id) .HasColumnName(\"StudentId\"); builder .HasMany(p => p.Addresses) .WithOne(p => p.Student); } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolDbContext>, IStudentRepository { public StudentRepository(IDbContextFactory dbContextFactory, EventBag eventBag, IBoltOnClock boltOnClock) : base(dbContextFactory, eventBag, boltOnClock) { } } Note: Create your own repository like StudentRepository only if you want to override the Repository class' methods or if you want to add methods, else just register IRepository<Student> to Repository<Student, SchoolDbContext>","title":"Entity Framework Repository"},{"location":"data/#dbcontextfactory","text":"This factory uses IServiceProvider to resolve DbContexts, and if the request implements IQuery<> , it sets the DbContexts' ChangeTracker.QueryTrackingBehavior to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled to false with the help of MediatorContextInterceptor . Note: You could disable this behavior by removing the interceptor from the pipeline using RemoveInterceptor<TInterceptor> extension method.","title":"DbContextFactory"},{"location":"data/#cosmosdb","text":"In order to use CosmosDb, you need do the following: Install BoltOn.Data.CosmosDb NuGet package. Call BoltOnCosmosDbModule() in your startup's BoltOn() method. Create an entity by inheriting BaseEntity<TIdType> . The inheritance is not mandatory though. Create an options class by inheriting BaseCosmosDbOptions class. Use AddCosmosDb extension method to initialize options like URI, AuthorizationKey and Database Name. Inherit Repository<TEntity, TCosmosDbOptions> to create a repository for your entity. All the repository methods accept an optional parameter options. For some of the methods, RequestOptions can be passed and for some FeedOptions can be passed as the options object, take a look at the Repository<TEntity, TCosmosDbOptions> to see the implementation. Example: services.BoltOn(options => { options.BoltOnCosmosDbModule(); }); services.AddCosmosDb<SchoolCosmosDbOptions>(options => { options.Uri = \"<<SPECIFY URI>>\"; options.AuthorizationKey = \"<<SPECIFY AUTHORIZATION KEY>>\"; options.DatabaseName = \"<<DATABASE NAME>>\"; }); public class SchoolCosmosDbOptions : BaseCosmosDbOptions { } // Entity public class Student : BaseEntity<string> { [JsonProperty(\"id\")] public override string Id { get; set; } [JsonProperty(\"studentId\")] public int StudentId { get; set; } public string FirstName { get; set; } } // Repository public interface IStudentRepository : IRepository<Student> { } public class StudentRepository : Repository<Student, SchoolCosmosDbOptions>, IStudentRepository { public StudentRepository(SchoolCosmosDbOptions options, EventBag eventBag, IBoltOnClock boltOnClock) : base(options, eventBag, boltOnClock) { } } Note: Create your own repository like StudentRepository only if you want to override the Repository class' methods or if you want to add methods, else just register IRepository<Student> to Repository<Student, SchoolCosmosDbOptions> While using any property in CosmosDb query, make sure property name matches exactly as it is in stored in the document collection.","title":"CosmosDb"},{"location":"mediator/","text":"Mediator is the backbone of BoltOn. It follows the Request/Response and Command Message patterns. The main source of inspiration for the Mediator was Agatha , and various other projects like Brighter and MediatR . Request, Response and Handler In order to use the Mediator, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. ICommand To create a request that doesn't have any response and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. ICommand<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. IQuery<out TResponse> To create a request with response of type TResponse and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. If BoltOn.Data.EF package is installed and bolted, DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false in DbContextFactory . In case if you want a custom request type with a different isolation level, you could create an interface and customize UnitOfWorkOptionsBuilder by overriding it or by creating a new one. Check out this custom request type called IQueryUncommitted with isolation level ReadUncommitted here . The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IHandler<in TRequest> For handlers that do not return any response. IHandler<in TRequest, TResponse> For handlers that have responses. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } } Finally, inject IMediator anywhere in your application, like a controller in WebAPI or a MVC application, and call Process or ProcessAsync method. Check out the implemenation Mediator to know the internals. Example: [Route(\"api/[controller]\")] public class StudentsController : Controller { private readonly IMediator _mediator; public StudentsController(IMediator mediator) { this._mediator = mediator; } [HttpGet] public async Task<IEnumerable<StudentDto>> Get() { var students = await _mediator.ProcessAsync(new GetAllStudentsRequest()); return students; } } Interceptors Every request flows thru a set of built-in interceptors (mentioned below), and the execution of them can be controlled by implementing appropriate marker interfaces. StopwatchInterceptor This interceptor logs the time that a request enters and exits the pipeline. This interceptor is enabled only if the request implements IEnableStopwatchInterceptor interface. UnitOfWorkInterceptor This interceptor starts a transaction with an isolation level based on the interface like IQuery or ICommand etc., (mentioned above) that the request implements. This interceptor is enabled only if the request implements IEnableUnitOfWorkInterceptor You could create an interceptor by implementing IInterceptor interface, like this . If you want to enable or disable an interceptor based on a marker interface implementation, you can inherit BaseRequestSpecificInterceptor<T> Note: Interceptors from all the bolted modules and assemblies must be added explicitly in the registration tasks using AddInterceptor<TInterceptor> extension method. Interceptors get executed in the order they're added. Interceptors can be removed using RemoveInterceptor<TInterceptor> extension method. All the interceptors in the pipeline (in other packages) can be removed using RemoveAllInterceptors extension method. However, if this extension method is executed in a registration task and if there is another registration task after your registration task to add interceptors, those interceptors will be added to the pipeline. Unit of Work If you use Mediator and implement any of the interfaces like IQuery or ICommand, which in turn implements IEnableUnitOfWorkInterceptor , you need not worry about starting or committing unit of work, it will be done automatically using UnitOfWorkInterceptor . If you're not using Mediator and if you want to start a unit of work, you could call Get method in IUnitOfWorkManager by passing UnitOfWorkOptions based on your needs. It will start a new transaction with System.Transactions.TransactionScopeOption.RequiresNew . The default transaction isolation level is IsolationLevel.Serializable Note: Though it's possible to start a unit of work manually, please try to do avoid it, especially when there is already one, as having more than one unit of work isn't a proper way to build applications. This will be useful only when you want to query a database with an isolation level different from the one started by UnitOfWorkInterceptor . In case if you want to change the default transaction isolation level for all the requests or only certain requests, or if you want to change the TransactionTimeout, you can implement IUnitOfWorkOptionsBuilder like this or inherit UnitOfWorkOptionsBuilder and override the Build method.","title":"Mediator"},{"location":"mediator/#request-response-and-handler","text":"In order to use the Mediator, you need to create a request by implementing any of these interfaces: IRequest To create a request that doesn't have any response and doesn't require unit of work. IRequest<out TResponse> To create a request with response of type TResponse and doesn't require unit of work. ICommand To create a request that doesn't have any response and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. ICommand<out TResponse> To create a request with response of type TResponse and that requires require unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. IQuery<out TResponse> To create a request with response of type TResponse and that requires unit of work. A transaction with isolation level ReadCommitted will be started for the requests that implement this interface. If BoltOn.Data.EF package is installed and bolted, DbContexts' ChangeTracker.QueryTrackingBehavior will be set to QueryTrackingBehavior.NoTracking and ChangeTracker.AutoDetectChangesEnabled will be set to false in DbContextFactory . In case if you want a custom request type with a different isolation level, you could create an interface and customize UnitOfWorkOptionsBuilder by overriding it or by creating a new one. Check out this custom request type called IQueryUncommitted with isolation level ReadUncommitted here . The response can be any value or reference type. After declaring the request and the response, you need to create a handler by implementiong any of these interfaces: IHandler<in TRequest> For handlers that do not return any response. IHandler<in TRequest, TResponse> For handlers that have responses. Example: public class GetAllStudentsRequest : IQuery<IEnumerable<StudentDto>> { } public class GetAllStudentsHandler : IHandler<GetAllStudentsRequest, IEnumerable<StudentDto>> { public async Task<IEnumerable<StudentDto>> HandleAsync(GetAllStudentsRequest request, CancellationToken cancellationToken) { var students = new List<StudentDto> { new StudentDto { FirstName = \"first\", LastName = \"last\" } }; return await Task.FromResult(students); } } Finally, inject IMediator anywhere in your application, like a controller in WebAPI or a MVC application, and call Process or ProcessAsync method. Check out the implemenation Mediator to know the internals. Example: [Route(\"api/[controller]\")] public class StudentsController : Controller { private readonly IMediator _mediator; public StudentsController(IMediator mediator) { this._mediator = mediator; } [HttpGet] public async Task<IEnumerable<StudentDto>> Get() { var students = await _mediator.ProcessAsync(new GetAllStudentsRequest()); return students; } }","title":"Request, Response and Handler"},{"location":"mediator/#interceptors","text":"Every request flows thru a set of built-in interceptors (mentioned below), and the execution of them can be controlled by implementing appropriate marker interfaces. StopwatchInterceptor This interceptor logs the time that a request enters and exits the pipeline. This interceptor is enabled only if the request implements IEnableStopwatchInterceptor interface. UnitOfWorkInterceptor This interceptor starts a transaction with an isolation level based on the interface like IQuery or ICommand etc., (mentioned above) that the request implements. This interceptor is enabled only if the request implements IEnableUnitOfWorkInterceptor You could create an interceptor by implementing IInterceptor interface, like this . If you want to enable or disable an interceptor based on a marker interface implementation, you can inherit BaseRequestSpecificInterceptor<T> Note: Interceptors from all the bolted modules and assemblies must be added explicitly in the registration tasks using AddInterceptor<TInterceptor> extension method. Interceptors get executed in the order they're added. Interceptors can be removed using RemoveInterceptor<TInterceptor> extension method. All the interceptors in the pipeline (in other packages) can be removed using RemoveAllInterceptors extension method. However, if this extension method is executed in a registration task and if there is another registration task after your registration task to add interceptors, those interceptors will be added to the pipeline.","title":"Interceptors"},{"location":"mediator/#unit-of-work","text":"If you use Mediator and implement any of the interfaces like IQuery or ICommand, which in turn implements IEnableUnitOfWorkInterceptor , you need not worry about starting or committing unit of work, it will be done automatically using UnitOfWorkInterceptor . If you're not using Mediator and if you want to start a unit of work, you could call Get method in IUnitOfWorkManager by passing UnitOfWorkOptions based on your needs. It will start a new transaction with System.Transactions.TransactionScopeOption.RequiresNew . The default transaction isolation level is IsolationLevel.Serializable Note: Though it's possible to start a unit of work manually, please try to do avoid it, especially when there is already one, as having more than one unit of work isn't a proper way to build applications. This will be useful only when you want to query a database with an isolation level different from the one started by UnitOfWorkInterceptor . In case if you want to change the default transaction isolation level for all the requests or only certain requests, or if you want to change the TransactionTimeout, you can implement IUnitOfWorkOptionsBuilder like this or inherit UnitOfWorkOptionsBuilder and override the Build method.","title":"Unit of Work"},{"location":"optional/","text":"Logging BoltOn uses .NET Core's logger internally, with just a custom adapter to help in unit testing. You could use any logging provider as you wish, or you could inherit BoltOnLogger<TType> and override the logging methods. IQueryUncommitted In case if you want a custom request type which is completely different from IQuery or ICommand in terms of the transaction isolation level or transaction timeout, you could create one something like this: public interface IQueryUncommitted<out TResponse> : IRequest<TResponse>, IEnableUnitOfWorkInterceptor { } And then create a custom interceptor in case if you want to tweak the ChangeTrackerContext, like the one mentioned below and create a custom UnitOfWorkOptionsBuilder to change the transaction isolation level or timeout, like the one mentioned below . And, finally register them like this: serviceCollection.RemoveInterceptor<ChangeTrackerInterceptor>(); serviceCollection.AddInterceptor<CustomChangeTrackerInterceptor>(); serviceCollection.AddTransient<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>(); Interceptor You could create your custom interceptor for change tracking something like this: public class CustomChangeTrackerInterceptor : IInterceptor { private readonly ChangeTrackerContext _changeTrackerContext; public CustomChangeTrackerInterceptor(ChangeTrackerContext changeTrackerContext) { _changeTrackerContext = changeTrackerContext; } public async Task<TResponse> RunAsync<TRequest, TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken, Func<IRequest<TResponse>, CancellationToken, Task<TResponse>> next) where TRequest : IRequest<TResponse> { _changeTrackerContext.IsQueryRequest = request is IQuery<TResponse> || request is IQueryUncommitted<TResponse>; var response = await next(request, cancellationToken); return response; } public void Dispose() { } } UnitOfWorkOptionsBuilder You could create your custom UnitOfWorkOptionsBuilder to change the isolation level and/or transaction timeout based on request type something like this: public class CustomUnitOfWorkOptionsBuilder : IUnitOfWorkOptionsBuilder { private readonly IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> _logger; public CustomUnitOfWorkOptionsBuilder(IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> logger) { _logger = logger; } public UnitOfWorkOptions Build<TResponse>(IRequest<TResponse> request) { IsolationLevel isolationLevel; switch (request) { case ICommand<TResponse> _: case IQuery<TResponse> _: case ICommand _: _logger.Debug(\"Getting isolation level for Command or Query\"); isolationLevel = IsolationLevel.ReadCommitted; break; case IQueryUncommitted<TResponse> _: _logger.Debug(\"Getting isolation level for QueryUncommitted\"); isolationLevel = IsolationLevel.ReadUncommitted; break; default: throw new Exception(\"Request should implement ICommand<> or IQuery<> to enable Unit of Work.\"); } return new UnitOfWorkOptions { IsolationLevel = isolationLevel }; } }","title":"Optional"},{"location":"optional/#logging","text":"BoltOn uses .NET Core's logger internally, with just a custom adapter to help in unit testing. You could use any logging provider as you wish, or you could inherit BoltOnLogger<TType> and override the logging methods.","title":"Logging"},{"location":"optional/#iqueryuncommitted","text":"In case if you want a custom request type which is completely different from IQuery or ICommand in terms of the transaction isolation level or transaction timeout, you could create one something like this: public interface IQueryUncommitted<out TResponse> : IRequest<TResponse>, IEnableUnitOfWorkInterceptor { } And then create a custom interceptor in case if you want to tweak the ChangeTrackerContext, like the one mentioned below and create a custom UnitOfWorkOptionsBuilder to change the transaction isolation level or timeout, like the one mentioned below . And, finally register them like this: serviceCollection.RemoveInterceptor<ChangeTrackerInterceptor>(); serviceCollection.AddInterceptor<CustomChangeTrackerInterceptor>(); serviceCollection.AddTransient<IUnitOfWorkOptionsBuilder, CustomUnitOfWorkOptionsBuilder>();","title":"IQueryUncommitted"},{"location":"optional/#interceptor","text":"You could create your custom interceptor for change tracking something like this: public class CustomChangeTrackerInterceptor : IInterceptor { private readonly ChangeTrackerContext _changeTrackerContext; public CustomChangeTrackerInterceptor(ChangeTrackerContext changeTrackerContext) { _changeTrackerContext = changeTrackerContext; } public async Task<TResponse> RunAsync<TRequest, TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken, Func<IRequest<TResponse>, CancellationToken, Task<TResponse>> next) where TRequest : IRequest<TResponse> { _changeTrackerContext.IsQueryRequest = request is IQuery<TResponse> || request is IQueryUncommitted<TResponse>; var response = await next(request, cancellationToken); return response; } public void Dispose() { } }","title":"Interceptor"},{"location":"optional/#unitofworkoptionsbuilder","text":"You could create your custom UnitOfWorkOptionsBuilder to change the isolation level and/or transaction timeout based on request type something like this: public class CustomUnitOfWorkOptionsBuilder : IUnitOfWorkOptionsBuilder { private readonly IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> _logger; public CustomUnitOfWorkOptionsBuilder(IBoltOnLogger<CustomUnitOfWorkOptionsBuilder> logger) { _logger = logger; } public UnitOfWorkOptions Build<TResponse>(IRequest<TResponse> request) { IsolationLevel isolationLevel; switch (request) { case ICommand<TResponse> _: case IQuery<TResponse> _: case ICommand _: _logger.Debug(\"Getting isolation level for Command or Query\"); isolationLevel = IsolationLevel.ReadCommitted; break; case IQueryUncommitted<TResponse> _: _logger.Debug(\"Getting isolation level for QueryUncommitted\"); isolationLevel = IsolationLevel.ReadUncommitted; break; default: throw new Exception(\"Request should implement ICommand<> or IQuery<> to enable Unit of Work.\"); } return new UnitOfWorkOptions { IsolationLevel = isolationLevel }; } }","title":"UnitOfWorkOptionsBuilder"},{"location":"samples/","text":"In order to run the Samples projects, SQL server and RabbitMq should be configured. SQL Server You could run SQL in Docker using this command: docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1' -p 1433:1433 -d microsoft/mssql-server-linux:latest Please modify the port if SQL is already installed. After launching SQL server, connect to the SQL Server and create a database using this command - Create Database BoltOnSamples Configure the DbContext in the RegistrationTask like this: container.AddDbContext<SchoolDbContext>(options => { options.UseSqlServer(\"Data Source=127.0.0.1;initial catalog=BoltOnSamples;persist security info=True;User ID=sa;Password=Password1;\"); }); RabbitMq You could run RabbitMq in Docker using this command: docker run -d --name bolton-rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3-management If RabbitMq is running, you should be able to monitor from http://localhost:15672 (guest/guest is the default password) Configure the RabbitMq in the RegistrationTask like this: container.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); })); });","title":"Samples"},{"location":"samples/#sql-server","text":"You could run SQL in Docker using this command: docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1' -p 1433:1433 -d microsoft/mssql-server-linux:latest Please modify the port if SQL is already installed. After launching SQL server, connect to the SQL Server and create a database using this command - Create Database BoltOnSamples Configure the DbContext in the RegistrationTask like this: container.AddDbContext<SchoolDbContext>(options => { options.UseSqlServer(\"Data Source=127.0.0.1;initial catalog=BoltOnSamples;persist security info=True;User ID=sa;Password=Password1;\"); });","title":"SQL Server"},{"location":"samples/#rabbitmq","text":"You could run RabbitMq in Docker using this command: docker run -d --name bolton-rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3-management If RabbitMq is running, you should be able to monitor from http://localhost:15672 (guest/guest is the default password) Configure the RabbitMq in the RegistrationTask like this: container.AddMassTransit(x => { x.AddBus(provider => MassTransit.Bus.Factory.CreateUsingRabbitMq(cfg => { var host = cfg.Host(new Uri(\"rabbitmq://localhost:5672\"), hostConfigurator => { hostConfigurator.Username(\"guest\"); hostConfigurator.Password(\"guest\"); }); })); });","title":"RabbitMq"},{"location":"utilities/","text":"IBoltOnClock/BoltOnClock There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IBoltOnClock BoltOnAppCleaner It scans all the ICleanupTask in the assembly collection formed by BoltOn() method in the Startup and executes them in the reverse order of assembly dependencies. If your module needs any cleanup work like purging data, stopping bus, disposing objects etc., implement ICleanupTask and it will be invoked automatically when internal classes get disposed. In case if you want all the cleanup tasks to be invoked on demand, use the static method Clean() in this class. However, make sure that it gets called only once in your application. In a WebAPI, you could call this method using IApplicationLifetime: public void Configure(IApplicationBuilder app, IApplicationLifetime appLifetime) { app.UseMvc(); app.ApplicationServices.TightenBolts(); appLifetime.ApplicationStopping.Register(() => BoltOnAppCleaner.Clean()); } BoltOnServiceLocator Service Locator is an Anti-Pattern , so try to avoid using it. In case if you want to use it, you could use the Current property in the class which is of type IServiceProvider .","title":"Utilities"},{"location":"utilities/#iboltonclockboltonclock","text":"There are instances where you have to use static properties DateTime.Now or DateTimeOffset.UtcNow, which makes hard to unit test, in those instances you could inject IBoltOnClock","title":"IBoltOnClock/BoltOnClock"},{"location":"utilities/#boltonappcleaner","text":"It scans all the ICleanupTask in the assembly collection formed by BoltOn() method in the Startup and executes them in the reverse order of assembly dependencies. If your module needs any cleanup work like purging data, stopping bus, disposing objects etc., implement ICleanupTask and it will be invoked automatically when internal classes get disposed. In case if you want all the cleanup tasks to be invoked on demand, use the static method Clean() in this class. However, make sure that it gets called only once in your application. In a WebAPI, you could call this method using IApplicationLifetime: public void Configure(IApplicationBuilder app, IApplicationLifetime appLifetime) { app.UseMvc(); app.ApplicationServices.TightenBolts(); appLifetime.ApplicationStopping.Register(() => BoltOnAppCleaner.Clean()); }","title":"BoltOnAppCleaner"},{"location":"utilities/#boltonservicelocator","text":"Service Locator is an Anti-Pattern , so try to avoid using it. In case if you want to use it, you could use the Current property in the class which is of type IServiceProvider .","title":"BoltOnServiceLocator"}]}